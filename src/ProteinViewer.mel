/*
		ProteinViewer.mel
		
		Visualizador 3D Interactivo de Proteínas para Sistema Gráfico de Alto Nivel.
		
		Author: Patricia Ayala Gómez.
		
		Fecha de inicio: 16/03/2015

		Fecha de fin: 6/09/2015
*/


/********** SECONDARY PROCEDURES() **********/

global proc int openFile(){
	global int $fileID;
	global string $pdbName;

	$fileID = 0;


	//Selección de archivo PDB
	$fileName = `fileDialog2 -fm 1 -caption "Choose a PDB file" -fileFilter "*.pdb" -dialogStyle 2`;			//Ventana de diálogo que permite seleccionar un archivo de tipo PDB, abriéndolo a continuación.
	if (size($fileName) == 1){	
		$pdbName = $fileName[0]; 
		$fileID = `fopen $pdbName "r"`;
	} 
		
	return $fileID;
}

global proc string[] stringToCharArray(string $string){
    int $i;
    string $array[];
    $loops = size($string);
    for ($i=0; $i<$loops; $i++){
        $array[$i] = `substring $string (1+$i) (1+$i)`;
    }
    
    return $array;
}



global proc int isPositionEmpty(string $strArray[], int $p){
	if ($strArray[$p] == "") 
	    return 1;
	else 
	    return 0;
}


//Procedimiento que devuelve el caracter de $myString que se encuentra en la posición $pos
//Uso:	string $resultado = strGet($original, 4);
global proc string strGet(string $myString, int $pos){
    if (size($myString)>0)
    	return `substring $myString $pos $pos`;
    else 
    	return "ERROR: String vacío";
}

global proc float join(float $integer, float $decimal){
	if ($integer < 0) 
		return -1*( (-$integer) + ($decimal * 0.001) );
	else 
		return ($integer + ($decimal * 0.001));
}

//Procedimiento que posiciona cualquier forma en la posición dada por un vector
global proc setPosition(string $objectName, vector $position){	
	setAttr ($objectName + ".translate") -type double3 ($position.x) ($position.y) ($position.z);
}

global proc setPositionStrand(string $objectName, vector $position){	
	setAttr ($objectName + ".translate") -type double3 ($position.x) ($position.y) ($position.z);
}

global proc extrudeCylinder(string $curve, string $polygon, string $mode){
	//Sólo se utiliza la función para extruir las bases del ADN


	string $uno[] = `polyExtrudeFacet -constructionHistory 1 -keepFacesTogether 1 -pvx 9.722999054 -pvy 19.074 -pvz 8.651001401 -twist 0 -taper 1 -off 0 -thickness 0 -smoothingAngle 30 -inputCurve $curve $polygon `;
	//Devuelve el nombre de polyExtrudeFace*
	//print $uno[0];

	if ($mode == "slabs"){			//Los cilindros de las bases de ADN sí deben tener más subdivisiones que los cilindros de los enlaces normales
		string $num = `match "[0-9]+" $uno[0]`;
		//print ($num+"\n");
		int $n = $num;
		if ($n%2 == 0){
			setAttr ($uno[0] + ".divisions") 20;
		}
	}
}

global proc extrudeRibbon(string $curve, string $polygon, int $subdivisions){	//5000 bien. 1000 poco para 300 puntos.
	int $divisions = $subdivisions * 10;
	polyExtrudeFacet -constructionHistory 1 -keepFacesTogether 1 -pvx 9.722999054 -pvy 19.074 -pvz 8.651001401 -divisions $divisions -twist 180 -taper 1 -off 0 -thickness 0 -smoothingAngle 60 -inputCurve $curve $polygon;
}

global proc extrudeStrand(string $curve, string $polygon, int $twist){
	polyExtrudeFacet -constructionHistory 1 -keepFacesTogether 1 -pvx 9.722999054 -pvy 19.074 -pvz 8.651001401 -divisions 300 -twist $twist -taper 1 -off 0 -thickness 0 -smoothingAngle 60 -inputCurve $curve $polygon;
}

global proc assignShader(string $shaderName, float $color[], string $objectName){
	//Asignación de $shaderName a $objectName con $color

	string $shaderSG = $shaderName+"SG";								
	string $shaderType = "blinn";
	string $shaderNodeName;	

	$shaderNodeName = `shadingNode -asShader -shared $shaderType -name $shaderName`;
	sets -renderable true -noSurfaceShader true -empty -name $shaderSG;
	//print("creación de "+$shaderName);

	if (! `isConnected ($shaderName + ".outColor") ($shaderSG + ".surfaceShader")`){
		connectAttr ($shaderName + ".outColor") ($shaderSG + ".surfaceShader");
		setAttr($shaderName + ".color") ($color[0]/255) ($color[1]/255) ($color[2]/255);	//RGB to HSV
		setAttr($shaderName + ".diffuse") 0.8;	//Tono: 0 más oscuro -> 0.9 más claro
	} 

	//Asignación
	sets -forceElement $shaderSG $objectName;
}


global proc assignShaderHSV(string $shaderName, float $color[], string $objectName){
	//Asignación de $shaderName a $objectName con $color

	string $shaderSG = $shaderName+"SG";								
	string $shaderType = "blinn";
	string $shaderNodeName;	

	$shaderNodeName = `shadingNode -asShader -shared $shaderType -name $shaderName`;
	sets -renderable true -noSurfaceShader true -empty -name $shaderSG;
	//print("creación de "+$shaderName);

	if (! `isConnected ($shaderName + ".outColor") ($shaderSG + ".surfaceShader")`){
		connectAttr ($shaderName + ".outColor") ($shaderSG + ".surfaceShader");
		///////////////////////////////////////////////////////////////////
		setAttr($shaderName + ".color") ($color[0]) ($color[1]) ($color[2]);	//HSV
		///////////////////////////////////////////////////////////////////
		setAttr($shaderName + ".diffuse") 0.8;	//Tono: 0 más oscuro -> 0.9 más claro
	} 

	//Asignación
	sets -forceElement $shaderSG $objectName;
}




global proc assignExistingShader(string $shaderName, string $objectName){
	string $shaderSG = $shaderName+"SG";								
	string $shaderType = "blinn";
	string $shaderNodeName;	

	$shaderNodeName = `shadingNode -asShader -shared $shaderType -name $shaderName`;
	sets -renderable true -noSurfaceShader true -empty -name $shaderSG;


	if (! `isConnected ($shaderName + ".outColor") ($shaderSG + ".surfaceShader")`){
		connectAttr ($shaderName + ".outColor") ($shaderSG + ".surfaceShader");
	}

	//Asignación
	sets -forceElement $shaderSG $objectName;
}

global proc vector calculateMidPoint(vector $coordA, vector $coordB){
	vector $result = << ($coordA.x+$coordB.x)/2, ($coordA.y+$coordB.y)/2, ($coordA.z+$coordB.z)/2 >>;
	return $result;
}

/********** calculateSceneMidPoint() **********/
/*Aug 6*/
global proc calculateSceneMidPoint(){
	global vector $midPoint;
	global float $bbox[];
	global vector $point1;
	global vector $point2;

	$bbox = exactWorldBoundingBox ("Scene");	//0, 1, 2; 3, 4, 5;
	$point1 = << $bbox[0], $bbox[1], $bbox[2]>>; 
	$point2 = << $bbox[3], $bbox[4], $bbox[5]>>; 

	//$midPoint = << ($point1.x+$point2.x)/2, ($point1.y+$point2.y)/2, ($point1.z+$point2.z)/2 >>;
	$midPoint = calculateMidPoint($point1, $point2);
}



/********** changeMaterial(string $shaderName, string $replaceType) **********/
/*
Tipos de material disponibles: {Predeterminado: blinn, lambert, phong }
*/
global proc changeMaterial(string $shaderName, string $replaceType){
	// This would be the desired Material type
	//string $replaceType = "lambert";

	string $replaceWith = `createNode $replaceType`;

	replaceNode $shaderName $replaceWith;

	// Not strictly necessary...
	showEditor $replaceWith;

	delete $shaderName;

	// Rename the new node to match the original.
	rename $replaceWith $shaderName;
}

global proc changeAllMaterials(string $replaceType){
	string $shaders[] = `ls -mat "*_Shader"`;

	for ($s=0; $s<size($shaders); $s++){
		if ($shaders[$s] != "cube_Shader"){
			changeMaterial($shaders[$s], $replaceType);
		}
	}

	//if phong: ofrecer la opción de  ".reflectivity" 0;


}




/********** readPDB() **********/
/*

Description: Reads a PDB file, storing the protein in new data structures

	Date of creation: April 6 2015.  

	Date of finish of the ATOM, HETATM & TER modules: April 21 2015.

	Date of creation and finish of the module to ignore the record types which are useless in the drawing of the molecule: May 1 2015.

	Date of start researching for the CONECT module: June 1 2015.

	Date of start of the CONECT module: June 15 2015.

	Date of finish of the CONECT module: June 29 2015.

	LINK module: No lo he hecho como tal (no guardo su información), sino que la información que 
		ofrece la doy por sabida y la he metido automáticamente en la representación de los enlaces heterógenos.

	Date of start of the HELIX module: July 8 2015.

	Date of finish of the HELIX module: July 9 2015.

	Date of start of the SHEET module: July 21 2015.

	Date of finish of the SHEET module: July 22 2015.
*/
global proc readPDB(int $fileID){
																		/***** DECLARATION OF VARIABLES *****/
	/*PDB File*/
	global string $pdbName;						//Nombre del fichero PDB
	global int $fileID;							//ID del fichero, para su control
	int $nLines;								//Tamaño en líneas del fichero
	global string $title;	//TITLE
	global string $header;	//HEADER
	global string $compnd;	//COMPND
	global string $keywds;	//KEYWDS
	global string $author;	//AUTHOR
	global string $source;	//SOURCE
	global string $expdta;	//EXPDTA

	
	/*Molecular elements*/
	global string $recordTypes[];				//ATOM, HETATM, TER, HELIX...
	global string $atomNames[];					//N, NE, NE2, NE2A...
												//Nombres de los átomos, formados por su elemento (letra), su cercanía (letra) y su indicador de rama (número)
												//Sólo existen en los Record Types de tipo ATOM y HETATM
												//La posición 0 de $atomNames está vacía para facilitar los recorridos por los vectores

	global string $residueNames[];				//HIS, TYR, DA, A...
	global string $chains[];					//A, B, C...
	global int $residueNumbers[];				//1, 1, 1, 2, 2, 2... 
	global vector $coordinates[];				//Array de vectores (triplets of X, Y, Z), $xyzArray[] <<X, Y, Z>>
	global string $elements[];					//STRING, O, C, N, FE...



	global string $standardAminoAcids[];		
	global string $nucleotides[];


	global string $moleculeMode;



	global int $ballAndStickOrCPK;				//ball & stick = 1
												//cpk = 0

	global int $isBallAndStickFull;				//Indica si están calculados los enlaces entre HETATM o si también están los entre ATOM
												//$isBallAndStickFull = 0 -> HETATM
												//$isBallAndStickFull = 1 -> ATOM

												//Indica si el B&S ya se ha calculado: hetatm + atom
	global int $isThereCarcass;					//Si está calculada la carcasa de CPKStick

	global float $stickRadius;

	global string $aminoChainTraceCurrentShape;
	global string $dnaChainTraceCurrentShape;




	global string $sceneElements[];				//Elementos sin repetir [N, C, O]
	global string $sceneResidues[];				//Nombres de residuos sin repetir [MET, ASN, THR]
	global string $sceneAminoAcids[];
	global string $sceneNucleotides[];
	global string $sceneStandardResidues[];
	global string $sceneNonStandardResidues[];	//HYP, GLY...
	global string $sceneNonStandardResiduesNiceNames[];
	global string $lastChar;
	global string $sceneChains[];
	global int $numberOfChains;					//Sacarlo a partir de TER. Para saber el número de cadenas en la escena.




	/*Conect*/
	global int $atomConnections[];				//Vector con los datos de CONECT
	global int $numConect;						//Número de records CONECT
	global int $numBonds;						//Número de enlaces atómicos, tanto ATOM como HETATM como sulfúricos


	
	/*Array counters*/
	global int $numberOfAtoms;					//Número de átomos
	global int $numberOfResidues;				//Número de aminoácidos presentes en la proteína
	global int $numberOfAtms;					//Records "ATOM"
	global int $numberOfHeterogens;				//records "HETATM" (residuos no pertenecientes a la proteína)
	global int $numberOfElements;				//size($sceneElements). Para saber el número de elementos en la escena.
	global int $numberOfSceneResidues;			//Número de residuos distintos que hay en la escena: {HOH, GLY, TYR} -> 3.
	


	/*Helixes*/
	global int $helixInitResNumbers[];
	global int $helixEndResNumbers[];
	global int $helixClass[]; 					//Clase de hélice: 5
	global int $helixLength[];					//Número de residuos de la hélice
	global int $numberOfHelixes;				//size of $helixInitResNames;
	global string $helixCurrentShape;



	/*DNA*/
	//Sólo puede haber o una o dos tiras de ADN por definición
	global int $dnaStrand1[];
	global int $dnaStrand2[];
	global int $sceneDnaStrands;
	global int $dnaBases;
	global int $slabsConnected;
	global int $isThereDNA;
	global int $numberOfSlabs;					//Número de bases
	global int $numbersOfBases[];





	/*Sheets*/
	global int $numberOfSheets;
	global int $numberOfStrands;

	global string $strandIds[];
	global string $sceneStrandIDs[];
	global int $sizes[];						//Número de strands en la sheet
	global int $residueLength[];
	global string $firstRes[];
	global string $firstChain[];
	global int $firstResNumber[];
	global string $lastRes[];
	global string $lastChain[];
	global int $lastResNumber[];

	global int $senses[];
	global string $sheetCurrentShape;




	/*Cámaras*/
	global float $bbox[];						//Dos puntos que definen la Bounding Box
	global vector $corner1;						//Esquina 1 de la Bounding Box
	global vector $corner2;						//Esquina 2 de la Bounding Box
	global vector $midPoint;					//Punto central de la molécula

	global string $frontCameraName;				//Cámara predeterminada
	global string $backCameraName;
	global string $rightCameraName;
	global string $leftCameraName;
	global string $spinCameraName;
	global string $topCameraName;

	global vector $frontCameraInitPos;
	global vector $backCameraInitPos;
	global vector $rightCameraInitPos;
	global vector $leftCameraInitPos;
	global vector $spinCameraInitPos;
	global vector $topCameraInitPos;

	global float $animationSpeed;
	global float $sceneWidth;
	global float $sceneHeight;



	/*Luces*/
	global vector $keyLightPosition;
	global vector $fillLightPosition;
	global vector $backLightPosition;

	global float $initialKeyIntensity;
	global float $initialFillIntensity;
	global float $initialBackIntensity;



	/*Rendering*/
	global int $renderWidth;
	global int $renderHeight;



	/*Keep being shown in the scene*/
	global int $keepHelixes;
	global int $keepSheets;
	global int $keepCarcass;
	global int $keepChainTraces;
	global int $keepSlabs;

	global string $colorMode;



	global string $alphabet[];

	global int $edgeAndFillTime;


	
	/*Temporal variables*/
	int $line;	 								//Posición actual de línea en el archivo PDB
	string $word; 								//Valor que retorna fgetword; palabra del fichero leyéndose actualmente
	int $i, $j;									//Contadores
	string $atomName;
	string $chain;
	string $residue;
	vector $xyz;								//Coordenadas XYZ para cada línea del fichero. Se guardarán en $coordinates
	string $element;
	float $valX, $valY, $valZ;



	
	
																		/***** INITIALIZATION OF VARIABLES *****/
	//Amino acid and nucleotide nomenclature
	$standardAminoAcids = {"ALA","CYS","ASP","GLU","PHE","GLY","HIS","ILE","LYS","LEU","MET","ASN","PRO","GLN","ARG","SER","THR","VAL","TRP","TYR"};
	$nucleotides = {"DA","DC","DG","DT"};
	$alphabet = {"A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"};

	$i = $j = $atoms = $numberOfAtoms = $numBonds = $numberOfResidues = $numberOfHelixes = $numberOfSheets = $numberOfChains = $numberOfHeterogens = $isThereDNA = $isBallAndStickFull = $isThereCarcass = 0;
	$stickRadius = 0.2;
	$edgeAndFillTime = 1;
	$numbersOfBases[0] = 0;
	$numbersOfBases[1] = 0;
	$numbersOfBases[2] = 0;
	$numbersOfBases[3] = 0;

	//Limpiar la escena por si hubo ejecuciones previas. clear vacía un array y pone su tamaño a cero
	clear $recordTypes;		
	clear $atomNames;
	clear $chains;
	clear $residueNames;
	clear $residueNumbers;
	clear $coordinates;
	clear $elements;
	clear $sceneResidues;
	clear $sceneElements;
	clear $sceneAminoAcids;
	clear $sceneNucleotides;
	clear $sceneStandardResidues;
	clear $sceneNonStandardResidues;
	clear $sceneNonStandardResiduesNiceNames;
	clear $atomConnections;
	clear $helixInitResNumbers;
	clear $helixEndResNumbers;
	clear $helixClass;
	clear $helixLength;
	clear $dnaStrand1;
	clear $dnaStrand2;
	clear $strandIds;
	clear $sizes;
	clear $firstRes;
	clear $firstChain;
	clear $firstResNumber;
	clear $lastRes;
	clear $lastChain;
	clear $lastResNumber;
	clear $senses;
	clear $residueLength;


	$header = $title = $keywds = $compnd = $author = $expdta = $source = "";
	

	//waitCursor -state on;
	
	$recordTypes[0] = "";
	$atomNames[0] = "";
	$residueNames[0] = "";
	$chains[0] = "";
	$valX = $valY = $valZ;
	


																/***** PROCEDURE *****/

	
	//Redirección al final del archivo a la cabecera MASTER para comprobar 
	//el número de átomos heterógenos con enlaces atómicos

	$word = `fgetword $fileID`;									//Primera palabra		
	int $posNumConect = 11;					

	while ($word != "MASTER"){									//No será "MASTER", así que se redirige a la cabecera final del archivo
		$word = `fgetline $fileID` ;							//Si la primera palabra de la línea no es "MASTER", se pasa a la siguiente línea
		$word = `fgetword $fileID` ;
	}

	//MASTER													//Llegar hasta numConect, de posición 11 
	for ($i=1; $i<=$posNumConect; $i++){
		if ($i == 9 && size($word) >= 5){
			//Aquí se pueden juntar 2
			$i++;
		}
			
		$word = `fgetword $fileID`;
		//print($word+" ");
	}

	$numConect = $word;											//Número de conexiones de heterógenos con enlaces atómicos
	print("NUM CONECT: "+$numConect+"\n");
	if ($numConect < 0){
		$atomConnections[0] = 0;
	}





	frewind $fileID;											//Vuelta al principio del archivo

	



	//Bucle de lectura y almacenamiento de los datos en pdbName

	$word = `fgetword $fileID`;									//[1-4] ATOM, HETATM	

	while (!`feof $fileID`){									//feof = 1: fin de archivo	

								/********** RECORD TYPE: ATOM, HETATM **********/

		if (   ($word == "ATOM")   ||   ($word == "HETATM")   ||   (size($word) > 7 && `match "HETATM[0-9]+" $word` != "")   ){

			$numberOfAtoms++;


			if ($word == "ATOM"){
				$line = `fgetword $fileID`;							//[7-11] Atom serial number. No necesitamos guardarlo en ningún vector.
				$recordTypes[$line] = "ATOM";
			} else if ($word == "HETATM")	{
				$line = `fgetword $fileID`;							//[7-11] Atom serial number. No necesitamos guardarlo en ningún vector.
				$recordTypes[$line] = "HETATM";
				$numberOfHeterogens++;
			} else if (size($word) > 7){	//"HETATM11824"
				$line = `match "[0-9]+$" $word`;		
				$recordTypes[$line] = "HETATM";
				$numberOfHeterogens++;
			}
			
		
			
								/********** ATOM NAME & RESIDUE NAME **********/

			/*TER tienen atom serial numbers. A la hora de pintar, hay que mirar $atomNames[$i] y si $recordTypes[$i] son ATOM o HETATM pero NO TER, se dibuja */

			$word = `fgetword $fileID`;							//[13-16, 17, 18-20] Atom name - Alternate location indicator - Residue name
			
			//No tengo en cuenta los átomos con Alternate location indicator, ya que son redundantes

			string $resName;
			if (size($word) < 4){						
				//Si el tamaño de la palabra leída es 5 o mayor, hay al menos 2 campos juntos
				//En este caso hay un espacio; por eso, $word es el nombre del átomo

				$atomNames[$line] = $word;						//[13-16] Atom name		

				// if ($word == "CA"){
				// 	$numberOfResidues++;
				// }	

				$resName = `fgetword $fileID`;					//[18-20] Residue name
				$residueNames[$line] = $resName;	
			}






										/**** Omisión de los códigos de inserción de residuos ****/
													/**** Omisión de los Hidrógenos ****/


			if (size($word) > 3 || size($resName) > 3 || $word == "H" || (startString($word, 1) == "H") ){		//atom name == 4 && resName >3

				//Saltarlo, borrar el nombre del átomo y la línea e ir a la línea siguiente
				if ($recordTypes[$line] == "HETATM")	$numberOfHeterogens--;
				$numberOfAtoms--;
				
				stringArrayRemoveAtIndex($line, $recordTypes);
				stringArrayRemoveAtIndex($line, $atomNames);
				stringArrayRemoveAtIndex($line, $residueNames);
				// $recordTypes[$line] = "";
				// $atomNames[$line] = "";				
				// $residueNames[$line] = "";					//AARG -> ARG

				$word = `fgetline $fileID`;						//Se pasa a la siguiente línea
				//print ($line+" skipped\n");
			} else {



											/**** Se continúa con la misma línea ****/

				//Añado $resName al vector $sceneResidues
				int $already = stringArrayContains($resName, $sceneResidues);
				if (!$already){
					//Si el residuo aún no estaba en el vector, se añade
					$sceneResidues[size($sceneResidues)] = $resName;

					if (size($resName) >= 3){
						//Aminoácido. Su abreviatura es de tamaño 3. 
						//Se comprueba si es un residuo estándar o no, ya sea amino o nucleótido
						if ($resName == "HOH"){
							$sceneNonStandardResidues[size($sceneNonStandardResidues)] = $resName;	//El agua no se encuentra buscando la palabra HETNAM (pero sí con HETATM), así que se añade como caso especial
							$sceneNonStandardResiduesNiceNames[size($sceneNonStandardResiduesNiceNames)] = "Water";
						} else {
							int $standard = stringArrayContains($resName, $standardAminoAcids);		//Se busca dentro del vector de residuos estándares, que ya los conocemos
							if (!$standard){
								$sceneNonStandardResidues[size($sceneNonStandardResidues)] = $resName;
								//print($resName+" ");
							} else {
								$sceneStandardResidues[size($sceneStandardResidues)] = $resName;
							}

							$sceneAminoAcids[size($sceneAminoAcids)] = $resName;	
						}
					} else {
						//Su tamaño es 2 o 1, por lo que puede ser Nucleótido o un Elemento químico no estándar (como el Cobre)
						//Se descarta que sea un Nucleótido buscándolo en el array
						int $isNucleotide = stringArrayContains($resName, $nucleotides);
						if (!$isNucleotide){
							//Entonces es un Elemento químico no estándar
							$sceneNonStandardResidues[size($sceneNonStandardResidues)] = $resName;
						} else {
							//Es un Nucleótido
							$sceneStandardResidues[size($sceneStandardResidues)] = $resName;
							$sceneNucleotides[size($sceneNucleotides)] = $resName;
						}

					}
				}	
				
				 
				
								/********** CHAIN IDENTIFIER & RESIDUE SEQUENCE NUMBER **********/
							
				$word = `fgetword $fileID`;							//[22] Chain identifier
				if (size($word) == 1){		
					//Caso A 100H
					$chains[$line] = $word; 						//A
					
					//100H
					$word = `fgetword $fileID`;						//[23-26] Residue sequence number - [27] Code for insertions of residues ("H")
					//Compruebo si hay una letra como último caracter de $word
					//string $last = strGet($word, size($word));
					string $last = `match "[A-Z-a-z]+$" $word`;


					if ($last != ""){
						//print("Last: "+$last+"\n");
						//Si hay una letra, es un código de inserción de residuos, y se descarta
						//print($last+"\n");
						$word = `substring $word 1 (size($word)-1)`;			//100
					}

					// if ($last != "0" && $last != "1" && $last != "2" && $last != "3" && $last != "4" && $last != "5" && $last != "6" && $last != "7" && $last != "8" && $last != "9" ){

					// }
					//100
					$residueNumbers[$line] = $word;
					if ($residueNumbers[$line] > $numberOfResidues)	$numberOfResidues = $residueNumbers[$line];

					//print($residueNumbers[$line]+" ");
				} else {											//[22] Chain identifier - [23-26] Residue sequence number - [27] Code for insertions of residues ("H")
					//Caso A2021H		
					//A
					string $last = strGet($word, 1);
					//Guardo la letra en el vector de cadenas
					$chains[$line] = $last;				
					//Elimino la letra del string
					$word = `substring $word 2 (size($word))`;		
							
					//2021H
					//Compruebo si hay una letra en la última posición 
					string $last = strGet($word, size($word));
					if ($last != "0" && $last != "1" && $last != "2" && $last != "3" && $last != "4" && $last != "5" && $last != "6" && $last != "7" && $last != "8" && $last != "9" ){
						//La tiene, y es un código de inserción de residuos, así que lo descarto
						//print($last+"\n");
						//Elimino la letra del string
						$word = `substring $word 1 (size($word)-1)`;
						//2021
						$residueNumbers[$line] = $word;
						if ($residueNumbers[$line] > $numberOfResidues)	$numberOfResidues = $residueNumbers[$line];
						//...H
					}
					//2021
				}
					


									/********** X Y Z COORDINATES **********/
					
				//[31-38] X Coordinate, [39-46] Y Coordinate, [47-54] Z Coordinate, [55-60] Occupancy, [61-66] Temperature factor
				float $pEntX, $pDecX, $pEntY, $pDecY, $pEntZ, $pDecZ;
				
				$pEntX = `fgetword $fileID "."`;
					
				$word = `fgetword $fileID ". "`;
				if (size($word) == 3){
					$pDecX = $word;
					$valX = join($pEntX, $pDecX);
					$pEntY = `fgetword $fileID "."`;
					$word = `fgetword $fileID ". "`;
					if (size($word) == 3){
						$pDecY = $word;
						$valY = join($pEntY, $pDecY);
						$pEntZ = `fgetword $fileID "."`;
						$word = `fgetword $fileID ". "`;
						if (size($word) == 3){
							$pDecZ = $word;
							$valZ = join($pEntZ, $pDecZ);
						} else if (size($word) > 3){
							$pDecZ = `substring $word 1 3`;
							$valZ = join($pEntZ, $pDecZ);
						}
					} else if (size($word) > 3){
						$pDecY = `substring $word 1 3`;
						$valY = join($pEntY, $pDecY);
						$pEntZ = `substring $word 4 7`;
						$word = `fgetword $fileID ". "`;
						if (size($word) == 3){
							$pDecZ = $word;
							$valZ = join($pEntZ, $pDecZ);
						} else if (size($word) > 3){
							$pDecZ = `substring $word 1 3`;
							$valZ = join($pEntZ, $pDecZ);
						}
					}//fin else if (size($word) > 3)
				} else if (size($word) > 3){
					$pDecX = `substring $word 1 3`;
					$valX = join($pEntX, $pDecX);
					$pEntY = `substring $word 4 7`;
					$word = `fgetword $fileID ". "`;
					if (size($word) == 3){
						$pDecY = $word;
						$valY = join($pEntY, $pDecY);
						$pEntZ = `fgetword $fileID "."`;
						$word = `fgetword $fileID ". "`;
						if (size($word) == 3){
							$pDecZ = $word;
							$valZ = join($pEntZ, $pDecZ);
						} else if (size($word) > 3){
							$pDecZ = `substring $word 1 3`;
							$valZ = join($pEntZ, $pDecZ);
						}//fin else if (size($word) > 3)
					} else if (size($word) > 3) {
						$pDecY = `substring $word 1 3`;
						$valY = join($pEntY, $pDecY);
						$pEntZ = `substring $word 4 7`;
						$word = `fgetword $fileID ". "`;
						if (size($word) == 3){
							$pDecZ = $word;
							$valZ = join($pEntZ, $pDecZ);
						} else if (size($word) > 3){
							$pDecZ = `substring $word 1 3`;
							$valZ = join($pEntZ, $pDecZ);
						}
					}//fin else if (size($word) > 3)
				}//fin else if (size($word) > 3)		
				
				//Las tres coordenadas se guardan en un vector, que posteriormente se añadirá al array coordinates
				$xyz = << $valX, $valY, $valZ >>;
				$coordinates[$line] = $xyz;
				
				//Terminamos de analizar la línea buscando el elemento químico del átomo.
				//Obviamos la temperatura y la occupancy.
				$word = `fgetword $fileID`;									//[73-78] Element symbol
				while (size($word) > 2){
					$word = `fgetword $fileID`;
				}
				$element = $word;
				$elements[$line] = $element;		

				//Añado el elemento al vector $sceneElements si no había uno ya dentro
				if (size($sceneElements) == 0){
					$sceneElements[0] = $element;
				} else {
					int $already = stringArrayContains($element, $sceneElements);
					if (!$already){
						//Si el elemento aún no estaba en el vector, se añade
						stringArrayInsertAtIndex(size($sceneElements), $sceneElements, $element);
					}
				}
			}//Fin procesado de una línea entera								
		}//Fin if "ATOM" || "HETATM"







									/********** RECORD TYPE: TER **********/

		//Indica la terminación de una cierta cadena 
		else if ($word == "TER"){
			//For proteins, the residue defined on the TER record is the carboxy-terminal residue; for nucleic acids it is the 3'-terminal residue.

			$line = `fgetword $fileID`;							//[7-11] Serial number
			$word = `fgetword $fileID`;							//[18-20] Residue name
			$residueNames[$line] = $word;
			$recordTypes[$line] = "TER";						//[1-3] TER

			$numberOfChains++;									//TER = Cadena nueva

			
									/********** CHAIN IDENTIFIER & RESIDUE SEQUENCE NUMBER **********/
									
			$word = `fgetword $fileID`;							//[22, 23-26, 27] Chain identifier - Residue sequence number - Code for insertion of residues
			//Caso A 100H
			if (size($word) == 1){						
				//A
				$chains[$line] = $word; 
				$word = `fgetword $fileID`;						//[23-26] Residue sequence number - [27] Code for insertions of residues ("H")
				//Caso 100H
				string $last = strGet($word, size($word));

				if ($last != "0" && $last != "1" && $last != "2" && $last != "3" && $last != "4" && $last != "5" && $last != "6" && $last != "7" && $last != "8" && $last != "9" ){
					//código de inserción de residuos se descarta
					$word = `substring $word 1 (size($word)-1)`;//100
					print("Code for insertions of residues: "+$last+"\n");
				}

				//100
				$residueNumbers[$line] = $word;
			} else {											//[22] Chain identifier
				//Caso A2021H				
				//A
				string $letter = strGet($word, 1);
				//Guardo la letra en el vector de cadenas
				$chains[$line] = $letter;				
				//Elimino la letra del string
				$word = `substring $word 2 (size($word))`;		
						
				//2021H
				//Compruebo si hay una letra en la última posición 
				string $last = strGet($word, size($word));

				if ($last != "0" && $last != "1" && $last != "2" && $last != "3" && $last != "4" && $last != "5" && $last != "6" && $last != "7" && $last != "8" && $last != "9" ){
					//La tiene, y es un código de inserción de residuos, así que lo descarto
					//Elimino la letra del string
					$word = `substring $word 1 (size($word)-1)`;
					//2021
					$residueNumbers[$line] = $word;
					//...H
				}
				//2021
			}//Fin else
		}//Fin while "TER"









								/********** RECORD TYPE: HETNAM **********/	

		//Nombre completo y abreviatura de residuos no estándar

		else if ($word == "HETNAM"){
			string $shortName = `fgetword $fileID`;			//HYP
			$sceneNonStandardResidues[size($sceneNonStandardResidues)] = $shortName;

			//Se guarda su nombre completo
			string $niceName = `fgetline $fileID`;			//4-HYDROXYPROLINE 
			$niceName = capitalizeString($niceName);
			$niceName = `substring $niceName 1 (size($niceName)-1)`;	//Quitar el último elemento, porque se guarda un \n
			$sceneNonStandardResiduesNiceNames[size($sceneNonStandardResiduesNiceNames)] = $niceName;
			print("HETNAM: "+$shortName+", "+$niceName+"\n");
		}
		







								/********** RECORD TYPE: CONECT **********/	

								/********** CONECT Bloque 1 ***********/


		else if ($word == "CONECT"){
			//Transformar la línea del fichero a un vector
			string $bonds = `fgetline $fileID`;


			string $vector[];
			string $sorted[];
			int $num = `tokenize $bonds $vector`;





			//Procesamiento de $vector (los tamaños de cada una de sus componentes)

			for ($i=0; $i<size($vector); $i++){
				int $size = size($vector[$i]);	//Tamaño de la componente actual del vector

				while ($size >= 6){		
					if (($i == 0) && ($sorted[0] == "")){	//111122222


						string $original = `substring $vector[0] 1 4`;	//1 5
						//print ("Original: "+$original+"\n");
						$sorted[0] = $original;
						
						int $sizePos0 = size($vector[0]);
						string $aux = `substring $vector[0] 5 $sizePos0`;	//6
						$vector[0] = $aux;
						$size = size($vector[0]);

						//Átomo original ya está guardado

					} else {	// $i = 1, 2, 3...
						//Estos ya se pueden guardar en cualquier orden, así que se hará de final a principio
						int $tmp = size($vector[$i]);
						string $next = `substring $vector[$i]  ($tmp-4) $tmp`;
						$sorted[size($sorted)] = $next;
						//print("Next: "+$next+"\n");

						//Quito de vector[i] a next
						int $unSize = size($vector[$i]);
						string $temp = `substring $vector[$i] 1 ($tmp-5)`;
						$vector[$i] = $temp;

						$size = size($vector[$i]);
					} 
				}//fin while size >= 6



				//Añadir el último enlace, que al ser de tamaño 5 se sale del while
				string $next = $vector[$i];
				$sorted[size($sorted)] = $next;
				$size = 0;

			}//fin for vector




			//Línea del fichero terminada
			for ($i=0; $i<size($sorted); $i++){
				$atomConnections[size($atomConnections)] = $sorted[$i];		//Se le añade $sorted a $atomConnections, actualizando así este último
			}

			$atomConnections[size($atomConnections)] = 0;					//Se le añade un 0, indicando el fin del procesamiento del CONECT
			clear $sorted;

		}//Fin while "CONECT"





								/********** CONECT Bloque 2 ***********/

		
		else if (`match "CONECT[0-9]+" $word` != ""){			//Comprobar que la nueva palabra no es de tipo "CONECT12345 1111 5555"
			string $record = `substring $word 1 6`;						// CONECT

			if ($record == "CONECT"){
				string $bonds = `substring $word 7 (size($word))`;		// 12345
				$bonds = $bonds + " " + `fgetline $fileID`;				// 12345 1111 5555


				//Transformar la línea del fichero a un vector
				string $vector[];
				string $sorted[];
				int $num = `tokenize $bonds $vector`;					//$num se ignora


				//Procesamiento de $vector (los tamaños de cada una de sus componentes)

				for ($i=0; $i<size($vector); $i++){	
					int $size = size($vector[$i]);

					while ($size >= 6){	//while
						if (($i == 0) && ($sorted[0] == "")){
							string $original = `substring $vector[0] 1 5`;

							$sorted[0] = $original;

							//Se actualizan los cambios para $vector[0]							
							int $sizePos0 = size($vector[0]);
							string $aux = `substring $vector[0] 6 $sizePos0`;
							$vector[0] = $aux;
							$size = size($vector[0]);

							//Átomo original ya está guardado

						} else {	// $i = 2, 3, 4...
							string $next = `substring $vector[$i] 1 5`;
							$sorted[size($sorted)] = $next;


							//Quito de vector[i] a next
							int $unSize = size($vector[$i]);
							string $temp = `substring $vector[$i] 6 $unSize`;
							$vector[$i] = $temp;

							$size = size($vector[$i]);

						} 
					}//fin while size >= 6



					//Añadir el último enlace, que al ser de tamaño 5 se sale del while
					string $next = $vector[$i];
					$sorted[size($sorted)] = $next;
					$size = 0;

				}//fin for vector



				//CONECT terminado
				for ($i=0; $i<size($sorted); $i++){
					$atomConnections[size($atomConnections)] = $sorted[$i];	//Se le añade $sorted a $atomConnections, actualizando así este último
				}

				$atomConnections[size($atomConnections)] = 0;					//Se le añade un 0, indicando el fin del procesamiento del CONECT



				// print("Sorted:\n");
				// print ($sorted);
				// print("\n\n\n");
				clear $sorted;

				// print("Atom connections: \n");
				// print($atomConnections);
				// print("\n\n\n");

			}//fin record conect
		}//fin línea y fin conect bloque 2









								/********** RECORD TYPE: HELIX **********/	
	
		else if ($word == "HELIX"){ 

			$word = `fgetword $fileID`;	//Número de hélice. Obviado.
			$word = `fgetword $fileID`;	//String alfanumérico de ID de hélice. Obviado. 
			$word = `fgetword $fileID`;	//Inicio nombre residuo. Obviado.
			$word = `fgetword $fileID`;	//Inicio cadena. Obviado.


			//Inicio de hélice
			$word = `fgetword $fileID`;
			$helixInitResNumbers[size($helixInitResNumbers)] = $word;


			$word = `fgetword $fileID`;	//Fin nombre residuo. Obviado.
			$word = `fgetword $fileID`;	//Fin cadena. Obviado.


			//Final de hélice
			$word = `fgetword $fileID`;
			$helixEndResNumbers[size($helixEndResNumbers)] = $word;


			//Tipo de hélice
			$word = `fgetword $fileID`;
			$helixClass[size($helixClass)] = $word;
			

			//Tamaño de hélice
			string $last = `fgetword $fileID`;
			while (size($last) > 3){						//Por si hubiera algun comentario entre medias
				$last = `fgetword $fileID`;		
			}
			$helixLength[size($helixLength)] = $last;

		}//Fin while "HELIX"

								







								/********** RECORD TYPE: SHEET **********/	
	
		else if ($word == "SHEET"){

			$word = `fgetword $fileID`;											//1. Número de strand en su sheet. Obviado.
			$strandIds[size($strandIds)] = `fgetword $fileID`;					//A. ID de strand.
			$sizes[size($sizes)] = `fgetword $fileID`;							//2

			$firstRes[size($firstRes)] = `fgetword $fileID`;					//THR
			$firstChain[size($firstChain)] = `fgetword $fileID`;				//A



			$firstRN = `fgetword $fileID`;										//5
			//Comprobar que $firstRN no tiene un código de inserción (letra) al final de él
			string $new = `match "[A-Z-a-z]+$" $firstRN`;


			if ($new != ""){
				//Hay un código de inserción que hay que eliminar
				//print("sheet código inserción: "+$firstRN+"\n");
				stringArrayRemoveAtIndex(size($strandIds), $strandIds);
				intArrayRemoveAtIndex(size($sizes), $sizes);
				stringArrayRemoveAtIndex(size($firstRes), $firstRes);
				stringArrayRemoveAtIndex(size($firstChain), $firstChain);

				$word = `fgetline $fileID`;	//Se salta el resto de la frase
			} else {
				//Comprobar que $firstRN no se encuentra ya en $firstResNumber[]

				int $n = intArrayFind($firstRN, 0, $firstResNumber);
				if ($n == -1){
					//No existe, así que lo añado.
					$firstResNumber[size($firstResNumber)] = $firstRN;				//5

					$lastRes[size($lastRes)] = `fgetword $fileID`;					//VAL
					$lastChain[size($lastChain)] = `fgetword $fileID`;				//A
					$lastResNumber[size($lastResNumber)] = `fgetword $fileID`;		//11

					$senses[size($senses)] = `fgetword $fileID`;					//0

					$word = `fgetline $fileID`;	//Se salta el resto de la frase
				} else {
					if ($firstChain[$n] != $firstChain[size($firstChain)-1]) {
						//print($firstChain[$n]+", "+$firstChain[size($firstChain)-1]+"\n");
						//Lo añado, ya que está en otra cadena
						$firstResNumber[size($firstResNumber)] = $firstRN;				//5
						$lastRes[size($lastRes)] = `fgetword $fileID`;					//VAL
						$lastChain[size($lastChain)] = `fgetword $fileID`;				//A
						$lastResNumber[size($lastResNumber)] = `fgetword $fileID`;		//11
						$senses[size($senses)] = `fgetword $fileID`;					//0

						$word = `fgetline $fileID`;	//Se salta el resto de la frase
					} else {
						//Se encuentra repetido y lo borro
						//Elimino los últimos elementos introducidos en los vectores anteriores
						stringArrayRemoveAtIndex(size($strandIds), $strandIds);
						intArrayRemoveAtIndex(size($sizes), $sizes);
						stringArrayRemoveAtIndex(size($firstRes), $firstRes);
						stringArrayRemoveAtIndex(size($firstChain), $firstChain);

						$word = `fgetline $fileID`;	//Se salta el resto de la frase
					}
				}
			}
		}







								/********** RECORD TYPE: END **********/	

		else if ($word == "END"){
			print("Lectura de PDB finalizada.\n");
		}




								/********** RECORD TYPE: TITLE **********/	

		else if ($word == "TITLE"){
			$word = `fgetline $fileID`;
			$title = $title + $word;
		}




								/********** RECORD TYPE: HEADER **********/	

		else if ($word == "HEADER"){
			$word = `fgetline $fileID`;
			$header = $word;
		}


								/********** RECORD TYPE: COMPND **********/

		else if ($word == "COMPND"){
			$word = `fgetline $fileID`;
			$compnd = $compnd + $word;
		}


								/********** RECORD TYPE: AUTHOR **********/

		else if ($word == "AUTHOR"){
			$word = `fgetline $fileID`;
			$author = $author + $word;
		}



								/********** RECORD TYPE: KEYWDS **********/

		else if ($word == "AUTHOR"){
			$word = `fgetline $fileID`;
			$keywds = $keywds + $word;
		}


								/********** RECORD TYPE: SOURCE **********/

		else if ($word == "SOURCE"){
			$word = `fgetline $fileID`;
			$source = $source + $word;
		}


								/********** RECORD TYPE: EXPDTA **********/

		else if ($word == "AUTHOR"){
			$word = `fgetline $fileID`;
			$expdta = $expdta + $word;
		}

								/********** RECORD TYPES TO IGNORE **********/

		else {
			$word = `fgetline $fileID`;
			//print($word+"\n");				
		}








								/***** SIGUIENTE PALABRA *****/ 

		$word = `fgetword $fileID`;						
		

	}//Fin while !eof	



	//Cálculos de vectores finales
	$numberOfElements = size($sceneElements);
	//Quitar residuos no estándar del vector de la escena, porque por mala documentación puede que se encuentren repetidos
	$sceneNonStandardResidues = stringArrayRemoveDuplicates($sceneNonStandardResidues);


	$sceneNonStandardResiduesNiceNames = stringArrayRemoveDuplicates($sceneNonStandardResiduesNiceNames);
	//ARREGLAMOS sceneNonStandardResiduesNiceNames, PORQUE ESTAN TODOS EN MAYÚSCULA
	if (size($sceneNonStandardResiduesNiceNames) > 0 ){
		for ($i=0; $i<size($sceneNonStandardResiduesNiceNames); $i++){
			if ($sceneNonStandardResiduesNiceNames[$i] != "Water"){
				string $lowered = `tolower($sceneNonStandardResiduesNiceNames[$i])`;

				string $firstChar = `substring $lowered 1 1`;
				$firstChar = `toupper $firstChar`;

				string $newLowered = `substring $lowered 2 (size($lowered))`;
				print $newLowered;

				string $final = ($firstChar + $newLowered);
				$sceneNonStandardResiduesNiceNames[$i] = $final;
			}
		}
	}

	//Arreglar los repetidos de $strandIDs
	$sceneStrandIDs = stringArrayRemoveDuplicates($strandIds);


	$nLines = (size($recordTypes)-1);			//Porque en la posición 0 no hay nada


	//Ordenación del vector de tipos de residuos presentes en la escena
	string $aux[] = `sort $sceneResidues`;
	$sceneResidues = $aux;

	
	$lastChar = $alphabet[$numberOfChains - 1];
	//$numberOfChains = getNumberOfChains($lastChar);
	$numberOfSceneResidues = size($sceneResidues);
	$numberOfAtms = $numberOfAtoms - $numberOfHeterogens;

    print ("last char "+$lastChar+" num cadenas: "+$numberOfChains);




	print("Header: "+$header+"\n");
	print("Título: "+$title+"\n");
	//print("antes del número de hélices\n");


	$numberOfHelixes = size($helixInitResNumbers);
	$numberOfStrands = size($firstResNumber);
	print("Número de hélices: "+$numberOfHelixes+"\n");

	for ($i=0; $i<size($senses); $i++){
		if ($senses[$i] == 0) $numberOfSheets++;
	}

	print("Número de sheets: "+$numberOfSheets+"\n");
	print("Número de strands: "+$numberOfStrands+"\n");




	// print("Atom connections:\n");
	// print($atomConnections);				//Vector con los datos de CONECT
	// print("Num conect: "+$numConect+", num bonds:"+$numBonds+"\n");

	// print("10: "+$atomNames[10]+" num: "+$residueNumbers[10]+"\n");
	// print("16: "+$atomNames[16]+" num: "+$residueNumbers[16]+"\n");
	// print("10740: "+$atomNames[10740]+" num res: "+$residueNumbers[10740]+"\n");
	// print("10743: "+$atomNames[10743]+" num res: "+$residueNumbers[10743]+"\n");
	// print("10747: "+$atomNames[10747]+" num res: "+$residueNumbers[10747]+"\n");
	// print("10936: "+$atomNames[10936]+" num res: "+$residueNumbers[10936]+"\n");
	// print("23144: "+$atomNames[23144]+" num res: "+$residueNumbers[23144]+"\n");
	// print("23201: "+$atomNames[23201]+" num res: "+$residueNumbers[23201]+"\n");


	// print("strand ids: ");
	// print(size($strandIds));
	// print("first res numbers: ");
	// print(size($firstResNumber));
	// print("first chain: ");
	// print(size($firstChain));
	// print("sizes: ");
	// print(size($sizes));

	// print($helixInitResNumbers);
	// print("\n\n");
	// print($helixEndResNumbers);
	// print("\n\n");




    	
	fclose $fileID;
	//waitCursor -state off;


}//End proc readPDB()





/********** drawAtoms() **********/
/*
Resumen: Pintado de los átomos como esferas y organización de la jerarquía de la molécula dibujada.
Descripción: El procedimiento obtiene todos los datos que se tienen de cada átomo, lo pinta y organiza
una jerarquía con los distintos elementos que forman la molécula dibujada.
Date: Creation: April 21 2015.  
Date: Ending: April 30 2015.
Date: Modification: 2-3 August 2015. (Hierarchy: sheets, helixes, bonds, etc.)


*/

global proc drawAtoms(){
	//Vuelta a declarar las variables globales de la molécula, puesto que se utilizarán en este procedimiento
	global string $recordTypes[];					//ATOM, HETATM, TER, HELIX...
	global string $atomNames[];						//N, NE, NE2, NE2A...
	global string $residueNames[];					//HIS, TYR, DA, A...
	global string $chains[];						//A, B, C...
	global int $residueNumbers[];					//1, 1, 1, 2, 2, 2... 
	global vector $coordinates[];					//Array de vectores (triplets of X, Y, Z), $xyzArray[] <<X, Y, Z>>
	global string $elements[];


	global string $sceneResidues[];
	global string $sceneElements[];
	global string $sceneStandardResidues[];
	global string $sceneNonStandardResidues[];
	global string $sceneNonStandardResiduesNiceNames[];
	global string $sceneAminoAcids[];
	global string $sceneNucleotides[];
	global int $isThereDNA;
	global int $numbersOfBases[];


	global int $numberOfAtoms;
	global int $numberOfHeterogens;
	global int $numberOfHelixes;
	global int $numberOfSheets;


	string $rN;
	string $elementGroupName;
	string $residueGroupName;
	string $chainGroupName;
	string $moleculeGroupName;



	//Nuevas variables
	string $group[]; 						
	string $temp;

	//Customización del Outliner
	outlinerEditor -niceNames 1 -sortOrder "dagName";




												/* Creación de las capas */

	//Minimal: {C, CA, N}
	//Oxigens: {O}
	//Side-chain: { ! (C, CA, N, O)}
	//HETATM: { recordTypes == HETATM }



	//Operaciones necesarias átomo por átomo
	for ($a=1; $a<=size($recordTypes); $a++){
		if ($recordTypes[$a] == "ATOM" || $recordTypes[$a] == "HETATM"){
			//Obtención de los datos disponibles del átomo actual





											/********** DIBUJADO DEL ÁTOMO **********/

			string $name;
			float $radius;
			float $color[];
			float $data[];
			float $x, $y, $z;
			string $atomNodeName[];		///Nombre del nodo esfera			
			string $shaderName;
			string $shaderNodeName;		//Nombre del nodo de tipo shader


			string $residue = $residueNames[$a];
			string $chain = $chains[$a];
			vector $position = $coordinates[$a];								
			string $element = $elements[$a];
			int $residueNumber = $residueNumbers[$a];
			$x = $position.x;
			$y = $position.y;
			$z = $position.z;

			int $isDNA = 0;		//Sólo con saber si es ATOM o HETATM no sé lo suficiente para decir si es ADN o no
								//Hay que mirar si su residuo es un nucleótido





			//Obtención de las características de la esfera
			$data = getCPKProperties($element);		






			if (($element != "O" && $element != "N" && $element != "C" && $element != "H" && $element != "S" ) || ($element == "S" && (`match "D[AGCT]+" $residue` != ""))) {
				//Cuidado con los azufres presentes en el ADN: if size($residue) == 3 : eso es que no es ADN
				//Aumentar el radio de la esfera si su átomo es HETATM, para que destaque su presencia

				//Puede ser que $element == "S", pero en ese caso, size($residue) == 3. 
				//Si size($residue) == 2 es que estamos en el S de ADN, que no se debe agrandar.

				$radius = $data[0]*0.8;		//Tamaño agrandado para destacar el HETATM
			} else {
				$radius = $data[0]*0.25;	//Tamaño predeterminado Ball & Stick	
			}


			$color = { $data[1], $data[2], $data[3] };

	


			if ($residue == "DG" || $residue == "DC" || $residue == "DT" || $residue == "DA"){
				$isDNA = 1;
				$isThereDNA = 1;

				//Contar que la base $residue ha aumentado

				if ($residue != $residueNames[$a-1]){
					if ($residue == "DA"){
						$numbersOfBases[0] = $numbersOfBases[0] + 1;
					} else if ($residue == "DC"){
						$numbersOfBases[1] = $numbersOfBases[1] + 1;
					} else if ($residue == "DG"){
						$numbersOfBases[2] = $numbersOfBases[2] + 1;
					} else if ($residue == "DT"){
						$numbersOfBases[3] = $numbersOfBases[3] + 1;
					}	
				}



			} else {
				$isDNA = 0;
			}



			if ($isDNA == 0) {
				if ($recordTypes[$a] == "ATOM"){
					$name = "atom_"+$atomNames[$a] + "_"+$a ;						//N_1, NE2_3, N1_5... Es relativo al residuo

				} else if ($recordTypes[$a] == "HETATM"){
					$name = "hetatm_"+$atomNames[$a] + "_"+$a;						//N_1, NE2_3, N1_5... Es relativo al residuo					
				}
			} else {
				string $aux = $atomNames[$a];	// C4' -> C4_

				if (size($aux) == 3 && $aux != "OP1" && $aux != "OP2"){
					//Hay que renombrarlo, ya que el apóstrofe no lo acepta bien Maya
					string $aux2 = `substring $aux 1 2`;
					$aux2 = $aux2 + "_";


					$name = "atom_"+ $aux2 + "_"+$a ;
				} else {

					$name = "atom_"+ $atomNames[$a] + "_"+$a ;
				}
			}






			//Creación de la esfera. 
			$atomNodeName = `sphere -radius $radius -name $name`;		//Transform node
			/***************************
			$atomNodeName[0] = $name, tipo transform
			$atomNodeName[1] = "makeNurbSphere1", tipo makeNurbSphere
			*****************************/


			//Posicionar la esfera
			move -ws $x $y $z $atomNodeName[0];	


			//Creación del Shader, del Shading Group y del Set
			$shaderName = $element+"_Shader";	//Shader: "H_Shader"
			assignShader($shaderName, $color, $name);









								/********** ORGANIZACIÓN DE LA JERARQUÍA DE LA MOLÉCULA **********/


			//Preparación de las cadenas que se utilizarán en la creación de la jerarquía
			//Las cadenas/grupos son de tipo: Elemento, Residuo, Cadena y Molécula

			//Cambios para facilitar la ordenación alfabética de los grupos residuo
			//$residueNumber es INT
			if ($residueNumber >= 1 && $residueNumber <= 9){
				$rN = ("00"+$residueNumber);	
			} else if ($residueNumber >= 10 && $residueNumber <= 99){
				$rN = ("0"+$residueNumber);	
			} else if ($residueNumber >= 100){
				$rN = $residueNumber;
			} else if ($residueNumber <= -1 && $residueNumber >= -9){
				$rN = ("00"+$residueNumber*-1);		//Es negativo, pero lo pongo como positivo
				//print($rN+" ");
			} else if ($residueNumber <= -10 && $residueNumber >= -99){
				$rN = ("0"+$residueNumber*-1);		//Es negativo, pero lo pongo como positivo
				//print($rN+" ");
			} else if ($residueNumber <= -100)
				$rN = $residueNumber;




			$elementGroupName = $element+"_Element_"+$chain+"_"+$rN+"_"+$residue;						//N_Element_A_001_TYR
			$residueGroupName = "Residue_"+$chain+"_"+$rN+"_"+$residue;									//Residue_A_1_TYR


			$chainGroupName = "Chain_"+$chain;								//Chain_A
			$moleculeGroupName = "Molecule";								//Molecule


										/* Organización por elementos */
			$group = `ls -transforms $elementGroupName`;					//N_Element_A_1_TYR
			if ($group[0] != ""){											//El grupo de elementos ya existía
				parent $atomNodeName[0] $group;								//Se añade la esfera al grupo de su elemento
			} else {														//Crear un nodo grupo de elementos donde insertarlo
				createNode transform -s -n $elementGroupName;				//N_Element_A_1_TYR
				//createNode transform -s -n $elementGroupName -p $atomNodeName[0]
				parent $atomNodeName[0] ("|"+$elementGroupName);			//NE1 -> N_Element_A_1_TYR
			}
			clear ($group);


										/* Organización por residuos */
			if ( ! isParentOf($residueGroupName, $elementGroupName) ){		//isParentOf(Parent, Child)
				//Si el grupo residuo no es padre del grupo elemento, éste último se le une
				createNode transform -s -n $residueGroupName;
				//$group = `ls -transforms $elementGroupName`;
				parent $elementGroupName $residueGroupName;
			}
			//clear ($group);


			/************************************************************************************/
										$moleculeMode = "secondary";
			/************************************************************************************/

		
			
		}//end for ($a=1; $a<=$recordTypes; $a++)	
	}
		


	showAtoms(0);	//Porque en el modo secundario sólo aparecen los hetatms	






										/* Organización por cadenas */
	$group = `ls -transforms "Residue_*"`;								//Se buscan los string de Residuo de la jerarquía
	for ($i=0; $i<size($group); $i++){									//Para cada residuo
		$c = strGet($group[$i], 9);										//Se comprueba su cadena, en la novena posición del string
		if ( ! isParentOf(("Chain_"+$c), $group[$i])){
			createNode transform -s -n ("Chain_"+$c);					//Chain_A
			parent $group[$i] ("Chain_"+$c);							//Residue_A_1_TYR -> Chain_A
		}	
	}
	clear($group);


									/* Organización por molécula */
	$group = `ls -transforms "|Chain_*"`;								//Se buscan los string de Cadena de la jerarquía
	if ($group[0] != ""){												//Se encuentran todos ellos (si hay)
		createNode transform -name $moleculeGroupName;					//Se añaden todos a la molécula
		parent $group $moleculeGroupName;								//Chain_A -> Molecule
	}
	clear($group);



									/* Organización de la jerarquía del resto de estructuras */

	string $curvesGroupName = "Curves";
	string $helixesGroupName = "Helixes";
	string $bondsGroupName = "Bonds";
	string $sheetsGroupName = "Sheets";
	string $backbonesGroupName = "Backbones";
	string $sensesGroupName = "Senses";

	createNode transform -s -n $curvesGroupName;
	createNode transform -s -n $bondsGroupName;
	createNode transform -s -n $backbonesGroupName;




	if ($numberOfHelixes > 0){
		createNode transform -s -n $helixesGroupName;
	}

	if ($numberOfSheets > 0){
		createNode transform -s -n $sheetsGroupName;
		createNode transform -s -n $sensesGroupName;
	}
}//end proc drawAtoms()






/********** drawCPK() ********** 
/*
Resumen: Pintado de la molécula en estilo CPK (tipos de esfera distintos para cada elemento), creación
y organización de la jerarquía de la molécula dibujada.
Descripción: El procedimiento obtiene todos los datos que se tienen de cada átomo, lo pinta y organiza
una jerarquía con los distintos elementos que forman la molécula dibujada.
Date: Creation: April 30 2015.  
Date: Ending: April 30 2015.
Date: Refinement, Switch between CPK and BallAndStick: 19 Aug.
Date: Refinement, Switch between (CPK+BallAndStick) -> Secondary 

	mode: { ballandstick, cpk, secondary, stick, wire }

*/
global proc drawCPK(string $nextMode){
	/*CPK: Como se dibuja posteriormente que el Ball & Stick, hay que recorrer todos los átomos
	y darles su nuevo tamaño, redimensionándolos*/
	global string $elements[];
	global int $numberOfHeterogens;
	global float $stickRadius;

	global int $keepHelixes;
	global int $keepSheets;
	global int $keepChainTraces;
	global int $keepCarcass;

	global int $isBallAndStickFull;
	global int $ballAndStickOrCPK;	// = 1. Lo pondremos a 0.
	global int $isThereCarcass;
	global int $isThereDNA;
	global string $moleculeMode;

	string $group[];
	


	//Is Ball&Stick complete? If not, draw the whole thing.
	if ($isBallAndStickFull == 0 && ($nextMode == "ballandstick" || $nextMode == "wire" || $nextMode == "stick")){
		drawBallAndStick("atom");	
	}







	if ($moleculeMode == "cpk"){

											/*** CPK ***/

		if ($nextMode == "ballandstick"){

																													/* CPK => Ball & Stick */

			print("CPK => Ball & Stick\n");

			showBonds(1);

			showWaters(0);		
			showSheets(0);
			showAllChainTraces(0);
			showHelixes(0);
			//showCarcass(0);


			if ($isThereCarcass == 0){
				$group = `ls "atom*" "*Element*|hetatm*"`;	
			} else {
				$group = `ls "Molecule|*|*|*|*" `;		//"Molecule|Chain*|Residue*|*Element*|*"
			}

			rescaleAtoms($group, $nextMode);	//ATOM + HETATM
			rescaleBonds($nextMode);


				/************************************************************************************/
											$moleculeMode = "ballandstick";
				/************************************************************************************/			

		} else if ($nextMode == "secondary"){

																													/* CPK => Secondary Structure */ 

			print("CPK => Secondary Structure\n");

			showAtoms(0);
			//hide "Molecule|Chain*|Residue*|*Element*|atom*"; 	//HETATM ya mostrados
			showWaters(0);
			showHelixes(1);
			showSheets(1);
			showAllChainTraces(1);
			showSlabs(1);


			if ($numberOfHeterogens > 0){

				showHidden "hetatm_*_bond*";
				
				if ($isThereCarcass == 0){
					$group = `ls "*Element*|hetatm*"`;	
				} else {
					$group = `ls "Molecule|*|*|*|hetatm*" `;		
				}	

				rescaleAtoms($group, $nextMode);	//HETATM
			}
			//Si no hay HETATM, no se dibujan átomos



				/************************************************************************************/
											$moleculeMode = "secondary";
				/************************************************************************************/

		} else if ($nextMode == "stick"){
																													/* CPK => Stick */ 

			print("CPK => Stick\n");

			if ($isThereCarcass == 0){
				$group = `ls "atom*" "*Element*|hetatm*"`;	
			} else {
				$group = `ls "Molecule|*|*|*|*" `;		
			}

			showBonds(1);

			rescaleAtoms($group, $nextMode);	//ATOM + HETATM
			rescaleBonds($nextMode);

				/************************************************************************************/
											$moleculeMode = "stick";
				/************************************************************************************/

		} else if ($nextMode == "wire"){
																													/* CPK => Wire */ 

			print("CPK => Wire\n");

			if ($isThereCarcass == 0){
				$group = `ls "atom*" "*Element*|hetatm*"`;	
			} else {
				$group = `ls "Molecule|*|*|*|*" `;		
			}

			showBonds(1);

			rescaleAtoms($group, $nextMode);	//ATOM + HETATM
			rescaleBonds($nextMode);

				/************************************************************************************/
											$moleculeMode = "stick";
				/************************************************************************************/

		} else if ($nextMode == "cpk"){
																													/* CPK => CPK */ 

			print("CPK\n");
		}










	} else if ($moleculeMode == "ballandstick"){

										/*** Ball&Stick ***/


		if ($nextMode == "cpk"){
																													/* Ball&Stick => CPK */

			print("Ball & Stick => CPK\n");

			showBonds(0);


			showAllAtoms(1); 		
			showWaters(1);		//Mostrar el agua, que conforma gran parte del modelo CPK
			showSheets(0);
			showAllChainTraces(0);
			showHelixes(0);




			//Re-escalar a tamaño CPK
			if ($isThereCarcass == 0){
				$group = `ls "atom*" "*Element*|hetatm*"`;	
			} else {
				$group = `ls "Molecule|*|*|*|*" `;		
			}

			rescaleAtoms($group, $nextMode);	//ATOM + HETATM

				/************************************************************************************/
											$moleculeMode = "cpk";
				/************************************************************************************/

		} else if ($nextMode == "secondary"){

																													/* Ball&Stick => Secondary Structure */

			print("Ball & Stick => Secondary Structure\n");

			showBonds(0);	//Esconder bonds
			showAllAtoms(0);	//Esconder atoms
							//bonds entre atom-atom y atom-hetatm

			//Y ahora mostramos lo necesario

			showWaters(0);
			showHelixes(1);
			showSheets(1);
			showAllChainTraces(1);
			showSlabs(1);


			if ($numberOfHeterogens > 0){

				//showHidden "Molecule|Chain*|Residue*|*Element*|hetatm*";
				showHetatms(1);
				string $hbonds[] = `ls "hetatm_*_bond*"`;
				if (size($hbonds) > 0 ) showHidden $hbonds;


				if ($isThereCarcass == 0){
					$group = `ls "*Element*|hetatm*"`;	
				} else {
					$group = `ls "Molecule|*|*|*|hetatm*" `;		
				}

				rescaleAtoms($group, $nextMode);	//HETATM
			}


				/************************************************************************************/
											$moleculeMode = "secondary";
				/************************************************************************************/

		} else if ($nextMode == "wire"){

																													/* Ball&Stick => Wire */
			print("Ball & Stick => Wire\n");

			//Escalar los átomos 
			if ($isThereCarcass == 0){
				$group = `ls "atom*" "*Element*|hetatm*"`;	
			} else {
				$group = `ls "Molecule|*|*|*|*" `;		
			}

			rescaleAtoms($group, $nextMode);	//ATOM + HETATM

			rescaleBonds($nextMode);

				/************************************************************************************/
											$moleculeMode = "wire";
				/************************************************************************************/

		} else if ($nextMode == "stick"){

																													/* Ball&Stick => Stick */
			print("Ball & Stick => Stick\n");

			//Escalar los átomos 
			if ($isThereCarcass == 0){
				$group = `ls "atom*" "*Element*|hetatm*"`;	
			} else {
				$group = `ls "Molecule|*|*|*|*" `;		
			}

			rescaleAtoms($group, $nextMode);	//ATOM + HETATM

			rescaleBonds($nextMode);	

				/************************************************************************************/
											$moleculeMode = "stick";
				/************************************************************************************/

		} else if ($nextMode == "ballandstick"){
																													/* Ball&Stick => Ball&Stick */ 

			print("Ball & Stick\n");
		}










	} else if ($moleculeMode == "secondary"){

									/*** Secondary structure ***/


		if ($nextMode == "wire"){

																												/* Secondary Structure => Wire */

			print("Secondary Structure => Wire\n");

			showAtoms(1);	//shoallatoms no funciona porque esa función checks si está en modo secundary para enseñar o no los atoms
			//hetatms ya están mostrados
			showBonds(1);

			drawWire();

			showHelixes(0);
			showSheets(0);
			showAllChainTraces(0);

			//Escala la propia función drawWire;


				/************************************************************************************/
											$moleculeMode = "wire";
				/************************************************************************************/

		} else if ($nextMode == "stick"){

																												/* Secondary Structure => Stick */

			print("Secondary Structure => Stick\n");

			showAtoms(1);
			showBonds(1);

			drawStick($stickRadius);	

			showWaters(0);
			showHelixes(0);
			showSheets(0);
			showAllChainTraces(0);

			//Escala la propia función drawStick;


				/************************************************************************************/
											$moleculeMode = "stick";
				/************************************************************************************/

		} else if ($nextMode == "cpk"){

																												/* Secondary Structure => CPK */

			print("Secondary Structure => CPK\n");

			//Al principio de esta función ya se calculó todo ball & stick

			showAtoms(1);
			showBonds(0);

			showWaters(1);
			showHelixes(0);
			showSheets(0);
			showAllChainTraces(0);

			if ($isThereCarcass == 0){
				$group = `ls "atom*" "*Element*|hetatm*"`;	
			} else {
				$group = `ls "Molecule|*|*|*|*" `;		
			}

			rescaleAtoms($group, $nextMode);	//ATOM + HETATM


				/************************************************************************************/
											$moleculeMode = "cpk";
				/************************************************************************************/

		} else if ($nextMode == "ballandstick"){

																												/* Secondary Structure => Ball & Stick */

			print("Secondary Structure => Ball & Stick\n");

			//Al principio de esta función ya se calculó todo ball & stick

			showAtoms(1);

			showWaters(0);
			showHelixes(0);
			showSheets(0);
			showAllChainTraces(0);
			showSlabs(0);
			showBonds(1);

			//Hay que escalar los hetatm 
			// for ($i=0; $i<size($sceneElements); $i++){
			// 	if ($sceneElements[$i] != "C" && $sceneElements[$i] != )
			// }
			string $biggerHetatms[] = `ls "hetatm_*"`;

			if ($isThereDNA == 1){
				string $phosphorus[] = `ls "atom_P_*"`;
				rescaleAtoms($phosphorus, "ballandstick");
			}



				/************************************************************************************/
											$moleculeMode = "ballandstick";
				/************************************************************************************/

		} else if ($nextMode == "secondary"){
																												/* Secondary Structure => Secondary Structure */
			print("Secondary Structure\n");

		}












	} else if ($moleculeMode == "wire"){

												/*** Wire ***/

			if ($nextMode == "stick"){

																													/* Wire => Stick */
				print("Wire => Stick\n");

				drawStick($stickRadius);

					/************************************************************************************/
												$moleculeMode = "stick";
					/************************************************************************************/

			} else if ($nextMode == "cpk"){

																													/* Wire => CPK */
				print("Wire => CPK\n");

				showBonds(0);

				if ($isThereCarcass == 0){
					$group = `ls "atom*" "*Element*|hetatm*"`;	
				} else {
					$group = `ls "Molecule|*|*|*|*" `;		
				}

				rescaleAtoms($group, $nextMode);	//ATOM + HETATM

					/************************************************************************************/
												$moleculeMode = "cpk";
					/************************************************************************************/

			} else if ($nextMode == "ballandstick"){

																													/* Wire => Ball & Stick */

				print("Wire => Ball & Stick \n");

				if ($isThereCarcass == 0){
					$group = `ls "atom*" "*Element*|hetatm*"`;	
				} else {
					$group = `ls "Molecule|*|*|*|*" `;		
				}

				rescaleAtoms($group, $nextMode);	//ATOM + HETATM

				rescaleBonds($nextMode);

					/************************************************************************************/
												$moleculeMode = "ballandstick";
					/************************************************************************************/

			} else if ($nextMode == "secondary"){

																													/* Wire => Secondary Structure */

				print("Wire => Secondary Structure \n");

				//hide "Molecule|Chain*|Residue*|*Element*|atom*"; 	//hetatm ya están mostrados
				showAtoms(0);	//sólo "atom". "hetatm" sí están mostrados.
				showBonds(0);		

				showWaters(0);
				showHelixes(1);
				showSheets(1);
				showAllChainTraces(1);
				showSlabs(1);


				if ($numberOfHeterogens > 0){
					showHidden "hetatm_*_bond*";

					if ($isThereCarcass == 0){
						$group = `ls "*Element*|hetatm*"`;	
					} else {
						$group = `ls "Molecule|*|*|*|hetatm*" `;		
					}

					rescaleAtoms($group, $nextMode);	//HETATM
					rescaleBonds($nextMode);	
				}


					/************************************************************************************/
												$moleculeMode = "secondary";
					/************************************************************************************/

			} else if ($nextMode == "wire"){
																													/* Wire => Wire */
				print("Wire\n");

			}












	} else if ($moleculeMode == "stick"){

												/*** Stick ***/

			if ($nextMode == "stick"){

																													/* Stick old radius => new Radius */
				drawStick($stickRadius);
				//print("Stick "+$stickRadius+"\n");
				//El nuevo radio se queda como el predeterminado para siguientes ejecuciones

					/************************************************************************************/
												$moleculeMode = "stick";
					/************************************************************************************/

			} else if ($nextMode == "wire"){

																													/* Stick => Wire*/
				drawWire();
				print("Stick => Wire\n");

					/************************************************************************************/
												$moleculeMode = "wire";
					/************************************************************************************/

			} else if ($nextMode == "ballandstick"){

																													/* Stick => Ball & stick */
				if ($isThereCarcass == 0){
					$group = `ls "atom*" "*Element*|hetatm*"`;	
				} else {
					$group = `ls "Molecule|*|*|*|*" `;		
				}

				rescaleAtoms($group, $nextMode);
				rescaleBonds($nextMode);	//ATOM + HETATM

				print("Stick => \n");

					/************************************************************************************/
												$moleculeMode = "ballandstick";
					/************************************************************************************/

			} else if ($nextMode == "cpk"){

																													/* Stick => CPK */
				if ($isThereCarcass == 0){
					$group = `ls "atom*" "*Element*|hetatm*"`;	
				} else {
					$group = `ls "Molecule|*|*|*|*" `;		
				}

				showWaters(1);
				showBonds(0);

				rescaleAtoms($group, $nextMode);

				print("Stick => CPK\n");

					/************************************************************************************/
												$moleculeMode = "cpk";
					/************************************************************************************/

			} else if ($nextMode == "secondary"){

																													/* Stick => Secondary */
				print("Stick => Secondary Structure\n");

				showBonds(0);				
				showAllAtoms(0);

				showWaters(0);
				showHelixes(1);
				showSheets(1);
				showAllChainTraces(1);
				showSlabs(1);


				if ($numberOfHeterogens > 0){
					showHidden "hetatm_*_bond*";

					if ($isThereCarcass == 0){
						$group = `ls "*Element*|hetatm*"`;
						showHidden $group;
						// hide "atom*";	//hetatm ya están mostrados
						
					} else {
						$group = `ls "Molecule|*|*|*|hetatm*" `;	
						showHidden $group;
						// hide "Molecule|*|*|*|atom*"; 	//hetatm ya están mostrados
					}	
				}

				rescaleAtoms($group, $nextMode);	//HETATM
				rescaleBonds($nextMode);	//HETATM			


					/************************************************************************************/
												$moleculeMode = "secondary";
					/************************************************************************************/

			} 
	}




	//Mantener dibujados: hélices, sheets o chain traces.
	if ($keepHelixes == 1){
		showHelixes(1);
	}

	if ($keepSheets == 1){
		showSheets(1);
	}

	if ($keepChainTraces == 1){
		showAllChainTraces(1);
	}

	if ($keepCarcass == 1){
		if ($isThereCarcass == 0){
			drawCarcass();
		} else {
			showCarcass(1);	
		}
	}



	select -cl;
	print("MODE: "+$moleculeMode+"\n");
}//end proc drawCPK()






















/********** rescaleAtoms(string $group[], string $mode) ********** 
/*
Date: Creation: August 20 2015.  
Modes: { ballandstick, cpk, wire, stick, secondary }
*/
global proc rescaleAtoms(string $group[], string $nextMode){
	global string $elements[];
	global string $recordTypes[];
	global string $residueNames[];

	global float $stickRadius;


	float $scaleFactor;



	if ($nextMode == "ballandstick"){
		$scaleFactor = 0.25 ;
	} else if ($nextMode == "cpk"){
		$scaleFactor = 1 ;
	} else if ($nextMode == "wire"){
		$scaleFactor = 0.01 ;
	} else if ($nextMode == "stick"){
		$scaleFactor = $stickRadius ;
	} else if ($nextMode == "secondary"){
		$scaleFactor = 0.25;	//igual que ball and stick
	}

	//print ("scale factor: "+$scaleFactor+" y mode: "+$nextMode+"\n");


	for ($i=0; $i<size($group); $i++){
		string $a = `match "(_)+[0-9]+" $group[$i] `;	//*_*_140_* ;
		string $b = stringRemovePrefix($a, "_" );		//__128 -> _128
		int $id = stringRemovePrefix($b, "_");			//_128 -> 128     ||     128 -> 128

		string $name = $group[$i];
		string $element = $elements[$id];
		string $shaderName = $element+"_Shader";
		string $residue = $residueNames[$id];

		float $data[] = getCPKProperties($element);	
		float $color[] = { $data[1], $data[2], $data[3] };
		float $radius;




		if ( $nextMode == "cpk" || $nextMode == "ballandstick" || $nextMode == "secondary"){
			$radius = $data[0]*$scaleFactor;
		} else if ($nextMode == "stick" || $nextMode == "wire" ){
			$radius = $scaleFactor;
		} else if ($recordTypes[$id] == "atom"){
			$radius = $data[0]*$scaleFactor;
		} 


		if ($nextMode == "secondary"){	//esto no va
			if (($element != "O" && $element != "N" && $element != "C" && $element != "H") || ($element == "S" && (`match "D[AGCT]+" $residue` != ""))) {
				$radius = $data[0]*0.8;		//agrandado
			} else {
				$radius = $data[0]*$scaleFactor;
			}
		} 
			

		

		sphere -edit -radius $radius $group[$i];
		//assignExistingShader($shaderName, $name);		
	}	
}







/********** rescaleBonds(string $mode) ********** 
/*
Date: Creation: August 20 2015.  
Modes: { ballandstick, wire, stick }
*/
global proc rescaleBonds(string $mode){
	global float $stickRadius;
	float $bondRad;

	if ($mode == "ballandstick" || $mode == "secondary"){
		$bondRad = 0.25;
	} else if ($mode == "stick"){
		$bondRad = $stickRadius;
	} else if ($mode == "wire"){
		$bondRad = 0.01;
	} else {
		$bondRad = $stickRadius;
	}

	string $bonds[] = ` ls "polyCylinder*bond*" `;

	for ($j=0; $j<size($bonds); $j++){
	    setAttr ($bonds[$j]+".radius") $bondRad;
	}
}








/********** colorMonochrome() **********/
/*
Argumentos: Vector de float de tamaño 3
Resumen: Pintado de la molécula en estilo monocromo.
Descripción: El procedimiento obtiene todos los shaders existentes en la escena y cambia el color 
	de cada uno de ellos al nuevo color que se desee.
Date: Creation: August 30 2015.  
*/
global proc colorMonochrome(float $color[]){	
	//Crea un shader nuevo y se lo asigna a todos los átomos
	global int $numberOfHelixes, $numberOfSheets, $isThereDNA;
	global string $colorMode;
	
	//string $shaderName = "monochrome_Shader";
	string $monoShader[] = `ls -mat "monochrome_Shader"`;
	//print $colorMode;


	if (size($monoShader) > 0){
		//Ya está creado y sólo hay que cambiarle el color
		//Y volver a asignarlo
		setAttr("monochrome_Shader" + ".color") -type double3 ($color[0]) ($color[1]) ($color[2]);		
		select -clear;
		//select -add "*atom*";
		select -add "Bonds";
		select -add "Molecule";
		select -add "Backbones";
		if ($numberOfHelixes > 0) select -add "Helixes";
		if ($numberOfSheets > 0) select -add "Sheets" "sense*";


		string $objects[] = `ls -dag -leaf -selection`;
		for ($i=0; $i<size($objects); $i++){
			if ($i == 0){
				assignShaderHSV("monochrome_Shader", $color, $objects[$i]);	//le asigno el color
			} else {
				assignExistingShader("monochrome_Shader", $objects[$i]);
			}
		}

	} else {
		//Aún nunca se ha creado este shader
		//Selection de los objetos a los que queremos añadirles el shader
		select -clear;
		//select -add "*atom*";
		select -add "Bonds";
		select -add "Molecule";
		select -add "Backbones";
		if ($numberOfHelixes > 0) select -add "Helixes";
		if ($numberOfSheets > 0) select -add "Sheets";


		string $objects[] = `ls -dag -leaf -selection`;
		//Crear shader

		for ($i=0; $i<size($objects); $i++){
			if ($i == 0){
				assignShaderHSV("monochrome_Shader", $color, $objects[$i]);
			} else {
				assignExistingShader("monochrome_Shader", $objects[$i]);
			}
		}
	}

	$colorMode = "monochrome";
}








/********** colorCPK() **********/
/*
Argumentos: Vector de float de tamaño 3
Resumen: Pintado de la molécula en estilo CPK, en el cual cada elemento tiene un color asociado.
Descripción: Es un procedimiento "de vuelta atrás", puesto que los shaders de los elementos químicos se crearon en el momento
	de dibujar cada átomo. Por ello, sólo hay que volver a asignarlos a su átomo o enlace apropiado.
Date: Creation: August 30 2015.  
*/
global proc colorCPK(){
	//Cambia los colores de todos los shaders existentes
	//string $shaders[] = `ls -mat "*_Shader"`;
	global string $sceneElements[];
	global string $colorMode;
	global string $elements[];
	global string $recordTypes[];
	global int $numberOfHeterogens;



	if ($colorMode != "cpk"){
		select -clear;
		// if ($numberOfHeterogens > 0){
		// 	select "atom*" "*Element*|hetatm*";
		// } else {
		// 	select "atom*";
		// }

		string $atoms[] = `ls "atom*"`;

		for ($i=0; $i<size($atoms); $i++){
			if ($atoms[$i] != ""){
				$s = ` match "[0-9]+$" $atoms[$i] `;
				if ($s != ""){
					int $n = $s;
					//$n = número de átomo
					string $element = $elements[$n];
					string $shaderName = $element+"_Shader";

					assignExistingShader($shaderName, $atoms[$i]);	
				}
			}
		}






		string $hetatms[] = `ls "*Element*|hetatm*"`;

		for ($i=0; $i<size($hetatms); $i++){
			if ($hetatms[$i] != ""){
				$s = ` match "[0-9]+$" $hetatms[$i] `;
				if ($s != ""){
					int $n = $s;
					//$n = número de átomo
					string $element = $elements[$n];
					string $shaderName = $element+"_Shader";

					assignExistingShader($shaderName, $hetatms[$i]);	
				}
			}
		}






		string $bonds[] = `ls "*bond*"`;

		for ($i=0; $i<size($bonds); $i++){
			if ($bonds[$i] != ""){
				string $el = ` match "[A-Z]+" $bonds[$i] `;	//En los enlaces viene incluido el símbolo químico 
				if ($el != ""){
					string $shaderName = $el+"_Shader";
					assignExistingShader($shaderName, $bonds[$i]);	
				}
			}
		}
	}



	$colorMode = "cpk";

}








/********** colorChains() **********/
/*
Resumen: Pintado de la molécula en estilo CPK con un color distinto para cada cadena de residuos, 
creación y organización de la jerarquía de la molécula dibujada.
Descripción: El procedimiento obtiene todos los datos que se tienen de cada átomo, lo pinta y organiza
una jerarquía con los distintos elementos que forman la molécula dibujada.
Date: Creation: April 30 2015.  
Date: Ending: May 1 2015.
*/
// global proc colorChains(){
// 	//string $group[] = `ls -mat "*_Shader"`; //Coger todos los shaders y quitarlos de cada nodo
// 	//Seleccionar todos los grupos cadena en la jerarquía de la escena
// 	string $group[] = `ls -transforms "Chain_*"`;
// 	int $nChains = size($group);

// 	for ($i=0; $i<$nChains; $i++){
// 		//Obtener la letra de la cadena
// 		string $letter = strGet($group[$i], 7);
// 		float $color[] = getCPKChainProperties($letter);
// 		string $shaderName = "Chain_"+$letter+"_Shader";		//Chain_A_Shader		
// 		string $chainGroupName = $group[$i];					//Chain_A

// 		assignShader($shaderName, $color, $group[$i]);
// 	}
// }
/*
Procedimiento que sirve tanto para colorear átomos+enlaces en sus respectivos modos, como para las estructuras del modo secundario: hélices, bases...
*/
global proc colorChains(){
	global int $numberOfChains, $numberOfHelixes, $numberOfSheets ;
	global string $alphabet[];
	global string $colorMode;


	//Si ya se crearon los shaders...
	string $chainShaders[] = `ls -mat "Chain_*_Shader"`;

	if (size($chainShaders) > 0){
		//Estaban creados

		for ($i=0; $i<$numberOfChains; $i++){
			string $letter = $alphabet[$i];
			string $shaderName = ("Chain_"+$letter+"_Shader");

			// string $atoms[] = `ls -dag -leaf ("Chain_"+$letter)`;	//ls -dag -s tienen que salir las shapes
			// string $bonds[] = `ls -dag -leaf ("Bonds|*_"+$letter) `;
			//float $color[] = getCPKChainProperties($letter);	//mismo color para todos

			//select ("*ChainTrace_"+$letter);
			select ("*_"+$letter);
			string $group[] = `ls -sl`;

			for ($i=0; $i<size($group); $i++){
				assignExistingShader($shaderName, $group[$i]);
			}
			// for ($a=0; $a<size($atoms); $a++){
			// 	assignExistingShader($shaderName, $atoms[$a]);
			// }

			// for ($a=0; $a<size($bonds); $a++){
			// 	assignExistingShader($shaderName, $bonds[$a]);
			// }
		}

	} else {

		//Crear y asignar
		for ($i=0; $i<$numberOfChains; $i++){
			string $letter = $alphabet[$i];
			//Crear un shader de cadena
			string $shaderName = ("Chain_"+$letter+"_Shader");
			float $color[] = getCPKChainProperties($letter);	//mismo color para todos




			string $atoms[] = `ls -dag -leaf ("Chain_"+$letter)`;		//ls -dag -s tienen que salir las shapes
			string $bonds[] = `ls -dag -leaf ("Bonds|*_"+$letter)`;		//Se incluyen aquí las bases de ADN
			string $cts[] = `ls -dag -leaf ("*ChainTrace_"+$letter)`;

		
			for ($a=0; $a<size($atoms); $a++){
				if ($a == 0){
					assignShader($shaderName, $color, $atoms[$a]);
				} else {
					assignExistingShader($shaderName, $atoms[$a]);
				}
			}

			for ($a=0; $a<size($bonds); $a++){
				if ($a == 0){
					assignShader($shaderName, $color, $bonds[$a]);
				} else {
					assignExistingShader($shaderName, $bonds[$a]);
				}
			}

			for ($a=0; $a<size($cts); $a++){
				if ($a == 0){
					assignShader($shaderName, $color, $cts[$a]);
				} else {
					assignExistingShader($shaderName, $cts[$a]);
				}
			}


			if ($numberOfHelixes > 0){
				string $h[] = `ls -dag -leaf ("*Helix*_"+$letter)`;
				for ($a=0; $a<size($h); $a++){
					if ($a == 0){
						assignShader($shaderName, $color, $h[$a]);
					} else {
						assignExistingShader($shaderName, $h[$a]);
					}
				}	
			}


			if ($numberOfSheets > 0){
				//Sheets
				string $s[] = `ls -dag -leaf ("*Sheet*_"+$letter)`;
				for ($a=0; $a<size($s); $a++){
					if ($a == 0){
						assignShader($shaderName, $color, $s[$a]);
					} else {
						assignExistingShader($shaderName, $s[$a]);
					}
				}	
				//Senses
				string $sen[] = `ls -dag -leaf ("sense*_"+$letter)`;
				for ($a=0; $a<size($sen); $a++){
					if ($a == 0){
						assignShader($shaderName, $color, $sen[$a]);
					} else {
						assignExistingShader($shaderName, $sen[$a]);
					}
				}
			}			
		}
	}


	$colorMode = "chain";
}









/********** colorResidues() **********/
/*
Resumen: Pintado de la molécula en estilo CPK con un color distinto para cada aminoácido,
creación y organización de la jerarquía de la molécula dibujada.
Descripción: El procedimiento obtiene todos los datos que se tienen de cada átomo, lo pinta y organiza
una jerarquía con los distintos elementos que forman la molécula dibujada.
Date: Creation: May 1 2015.  
Date: Ending: May 1 2015.
*/
// global proc colorResidues(){
// 	global string $sceneResidues[];
// 	//string $group[] = `ls -mat "*_Shader"`; //Coger todos los shaders y quitarlos de cada nodo
// 	//Seleccionar todos los grupos cadena en la jerarquía de la escena
// 	string $group[] = `ls -transforms "Residue_*"`;
// 	int $nRes = size($group);

// 	for ($i=0; $i<$nRes; $i++){
// 		//Obtener el nombre del residuo
// 		int $size = size($group[$i]);
// 		string $resName = `substring $group[$i] 15 $size`;
// 		//$resName puede tener un tamaño de 1 a 3
// 		//Tamaño 3: Aminoácidos
// 		//Tamaño 2: Deoxirribonucleótidos
// 		//Tamaño 1: Ribonucleótidos
// 		//print($resName+"\n");

// 		float $color[] = getCPKResidueProperties($resName);
// 		string $shaderName = "Residue_"+$resName+"_Shader";		//Residue_TYR_Shader
		
// 		assignShader($shaderName, $color, $group[$i]);	
// 	}
// 	//print(`ls -mat "Residue*Shader"`);
// 	//print($sceneResidues);
// }



// global proc colorResidues(){
// 	global string $sceneResidues[];
// 	//string $group[] = `ls -mat "*_Shader"`; //Coger todos los shaders y quitarlos de cada nodo
// 	//Seleccionar todos los grupos cadena en la jerarquía de la escena
// 	string $group[] = `ls -transforms "Residue_*"`;
// 	int $nRes = size($group);

// 	for ($i=0; $i<$nRes; $i++){
// 		//Obtener el nombre del residuo
// 		int $size = size($group[$i]);
// 		string $resName = `substring $group[$i] 15 $size`;
// 		//$resName puede tener un tamaño de 1 a 3
// 		//Tamaño 3: Aminoácidos
// 		//Tamaño 2: Deoxirribonucleótidos
// 		//Tamaño 1: Ribonucleótidos
// 		//print($resName+"\n");

// 		float $color[] = getCPKResidueProperties($resName);
// 		string $shaderName = "Residue_"+$resName+"_Shader";		//Residue_TYR_Shader
		
// 		assignShader($shaderName, $color, $group[$i]);	
// 	}
// 	//print(`ls -mat "Residue*Shader"`);
// 	//print($sceneResidues);
// }



global proc colorResidues(){
	global string $colorMode;
	global string $sceneResidues[];


	if ($colorMode != "residues"){
		//buscar si el material "Residue_resname_Shader" existe
		string $shaders[] = `ls -mat "Residue_*_Shader"`;


		if (size($shaders) > 0){
			//Están creados los shaders de residuo
			//Se procede a asignarlos 


		} else {
			//Selección de todos los residuos
			for ($i=0; $i<size($sceneResidues); $i++){
				$shaderName = ("Residue_"+$sceneResidues[$i]+"_Shader") ;
				float $color[] = getCPKResidueProperties($sceneResidues[$i]);



							/* Atoms */
				string $atoms[] = `ls ("Residue_*_"+$sceneResidues[$i]+"|*|*")`;
				// print ("Átomos del residuo "+$sceneResidues[$i]);
				// print $atoms;

				//Colorea todos los átomos en el residuo
				for ($a=0; $a<size($atoms); $a++){
					if ($a == 0){
						//Primera vez que se crea el shader
						assignShader($shaderName, $color, $atoms[$a]);
					} else {
						assignExistingShader($shaderName, $atoms[$a]);
					}
				}



							/* Bonds */
				string $bonds[] = `ls ("*bond*"+"_"+$sceneResidues[$i]+"_*")`;	//backbone_C_bond_2_to_3_HIS_A
				for ($a=0; $a<size($bonds); $a++){
					assignExistingShader($shaderName, $bonds[$a]);
				}

			}
		}
	}

	$colorMode = "residues";
}






global proc colorChainTrace(float $newColor[], int $default){
	float $defaultColor[] = {239,153,118};	//Beige
	string $chShader = "chainTrace_Shader";

	select "*ChainTrace*";
	string $group[] = `ls -sl`;

	if ($default == 1){
		setAttr($chShader+".color") ($defaultColor[0]/255) ($defaultColor[1]/255) ($defaultColor[2]/255);	//RGB to HSV

		for ($i=0; $i<size($group); $i++){
			assignExistingShader($chShader, $group[$i]);
		}
	} else {
		setAttr($chShader+".color") ($newColor[0]) ($newColor[1]) ($newColor[2]);	//RGB to HSV

		for ($i=0; $i<size($group); $i++){
			assignExistingShader($chShader, $group[$i]);
		}
	}
}





// global proc printInformation(){
// 	global int $numberOfAtoms;	//Atoms = ATOMS + HETATMS
// 	global int $numberOfHeterogens;
// 	global int $numberOfAtms;

// 	global string $sceneElements[];
// 	global string $sceneResidues[];
// 	global string $sceneAminoAcids[];
// 	global string $sceneNucleotides[];
// 	global string $sceneStandardResidues[];
// 	global string $sceneNonStandardResidues[];
// 	global string $sceneNonStandardResiduesNiceNames[];
// 	global int $isThereDNA;



// 									/*Muestra de la información recopilada de la molécula*/
// 	print("\nNumero de átomos totales: "+$numberOfAtoms);
// 	print("\nNúmero de átomos heterógenos: "+$numberOfHeterogens);
// 	//print("\nElementos: "+size($sceneElements)+"\n");
// 	//print($sceneElements);
// 	print("\n");
// 	//print(getElementsNiceNames($sceneElements));
// 	//print("\nLongitud (número de aminoácidos): "+$numberOfResidues);
// 	//print("\nNúmero de residuos distintos: "+size($sceneResidues)+"\n");
// 	//print($sceneResidues);

// 	//print(getResiduesNiceNames($sceneResidues));
// 	for($i=0; $i<size($sceneResidues); i++){
// 		$sceneResidues[$i];
// 	}

// 	//print("\nResiduos estándar: "+size($sceneStandardResidues)+"\n");
// 	//print($sceneStandardResidues);
// 	//print(getResiduesNiceNames($sceneStandardResidues));

// 	if (size($sceneStandardResidues) == 20){
// 		print("\nLa molécula está compuesta por todos los amino ácidos estándar.");
// 	}

// 	// if (size($sceneNonStandardResidues) > 0){
// 	// 	print("\nResiduos no estándar: "+size($sceneNonStandardResidues)+"\n");
// 	// 	print($sceneNonStandardResidues);	//Incluir vector de los nombres
// 	// 	print("\nResiduos no estándar nice names:\n");
// 	// 	print($sceneNonStandardResiduesNiceNames);
// 	// } 


// 	// if (size($sceneAminoAcids) > 0){
// 	// 	print("\n\nTipos de amino ácidos encontrados en la escena: "+size($sceneAminoAcids)+"\n");
// 	// 	//print(getResiduesNiceNames($sceneAminoAcids));
// 	// 	//print($sceneAminoAcids);
// 	// }


// 	if (size($sceneNucleotides) > 0){
// 		$isThereDNA = 1;
// 		print("\nNucleótidos: "+size($sceneNucleotides)+"\n");
// 		print($sceneNucleotides);
// 		//print(getResiduesNiceNames($sceneNucleotides));
// 		//print($sceneNucleotides);
// 	}
// }




/********** getCPKProperties() **********/
/*
Description: Devuelve un array de float de tamaño cuatro, compuesto por: { radio, R, G, B }
Date: Creation: April 21 2015.  
*/

global proc float[] getCPKProperties(string $element){	//float[4]
	switch($element){									//Radio, R, G, B
		case "H": return {1.2,255,255,255};		//Hidrogeno, blanco
		case "HE": return {1.4,217,255,255};
		case "LI": return {1.82,204,128,255};
		case "BE": return {1.53,194,255,0};
		case "B": return {1.92,255,181,181};	//Boro, rosa pastel
		case "C": return {1.7,144,144,144};		//Carbono, gris
		case "N": return {1.55,48,80,248};		//Nitrógeno, azul
		case "O": return {1.52,255,13,13};		//Oxígeno, rojo
		case "FE": return {1.47,144,224,80};
		case "NE": return {1.54,179,227,245};
		case "NA": return {2.27,171,92,242};
		case "MG": return {1.73,138,255,0};
		case "AL": return {1.84,191,166,166};
		case "SI": return {2.1,240,200,160};
		case "P": return {1.8,255,128,0};		//Fósforo, naranja
		case "S": return {1.8,255,255,48};		//Azufre, amarillo
		case "CL": return {1.75,31,240,31};
		case "AR": return {1.88,128,209,227};
		case "K": return {2.75,143,64,212};
		case "CA": return {2.31,61,255,0};
		case "SC": return {2.11,230,230,230};
		case "NI": return {1.63,80,208,80};
		case "CU": return {1.4,255,128,0};		//Cobre
		case "ZN": return {1.39,125,128,176};
		case "GA": return {1.87,194,143,143};
		case "GE": return {2.11,102,143,143};
		case "AS": return {1.85,189,128,227};
		case "SE": return {1.9,255,161,0};
		case "BR": return {1.85,166,41,41};
		case "KR": return {2.02,92,184,209};
		case "RB": return {3.03,112,46,176};
		case "SR": return {2.49,0,255,0};
		case "PD": return {1.63,0,105,133};
		case "AG": return {1.72,192,192,192};
		case "CD": return {1.58,255,217,143};
		case "IN": return {1.93,166,117,115};
		case "SN": return {2.17,102,128,128};
		case "SB": return {2.06,158,99,181};
		case "TE": return {2.06,212,122,0};
		case "I": return {1.98,148,0,148};
		case "XE": return {2.16,66,158,176};
		case "CS": return {3.43,87,23,143};
		case "BA": return {2.68,0,201,0};
		case "PT": return {1.75,208,208,224};
		case "AU": return {1.66,255,209,35};
		case "HG": return {1.55,184,184,208};
		case "TL": return {1.96,166,84,77};
		case "PB": return {2.02,87,89,97};
		case "BI": return {2.07,158,79,181};
		case "PO": return {1.97,171,92,0};
		case "AT": return {2.02,117,79,69};
		case "RN": return {2.2,66,130,150};
		case "FR": return {3.48,66,0,102};
		case "RA": return {2.83,0,125,0};
		case "U": return {1.86,0,143,255};

		default: return {1,0,0,0};	//Blanco
	}
}




/********** getCPKChainProperties() **********/
/*
Description: Devuelve un array de float de tamaño tres, compuesto por: { R, G, B }
Date: Creation: April 30 2015.  
*/

global proc float[] getCPKChainProperties(string $chain){
	switch($chain){										
		case "A": return {192,208,255};		
		case "B": return {176,255,176};		
		case "C": return {255,192,200};		
		case "D": return {255,255,128};		
		case "E": return {255,192,255};		
		case "F": return {176,240,240};		
		case "G": return {255,208,112};		
		case "H": return {240,128,128};		
		case "I": return {245,222,179};		
		case "J": return {0,191,255};		
		case "K": return {205,92,92};		
		case "L": return {102,205,170};		
		case "M": return {154,205,50};		
		case "N": return {238,130,238};		
		case "O": return {0,206,209};		
		case "P": return {0,255,127};		
		case "Q": return {60,179,113};		
		case "R": return {0,0,139};		
		case "S": return {189,183,107};		
		case "T": return {0,100,0};		
		case "U": return {128,0,0};		
		case "V": return {128,128,0};		
		case "W": return {128,0,128};		
		case "X": return {0,128,128};		
		case "Y": return {184,134,11};		
		case "Z": return {178,34,34};

		default: return {255,255,255};		//Negro
	}
}




/********** getCPKResidueProperties() **********/
/*
Description: Devuelve un array de float de tamaño tres, compuesto por: { R, G, B }
Date: Creation: May 1 2015.  
*/

global proc float[] getCPKResidueProperties(string $residue){
	switch($residue){		
		//Aminoácidos estándar							
		case "ALA": return {102,205,170};		//antes 200,200,200
		case "ARG": return {20,90,255};		
		case "ASN": return {0,220,220};		
		case "ASP": return {230,10,10};
		case "ASX": return {255,105,180};				
		case "CYS": return {230,230,0};		
		case "GLN": return {0,220,220};		
		case "GLU": return {230,10,10};		
		case "GLY": return {152,251,152};		//antes 235,235,235	
		case "GLX": return {255,105,180};				
		case "HIS": return {130,130,210};		
		case "ILE": return {15,130,15};		
		case "LEU": return {15,130,15};		
		case "LYS": return {20,90,255};		
		case "MET": return {230,230,0};		
		case "PHE": return {50,50,170};		
		case "PRO": return {220,150,130};		
		case "SER": return {250,150,0};		
		case "THR": return {250,150,0};		
		case "TRP": return {180,90,180};		
		case "TYR": return {50,50,170};		
		case "VAL": return {15,130,15};	

		case "UNK": return {190,160,110};		//Desconocido
		case "HOH": return {230,0,0};			//Agua


		//Deoxirribonucleótidos
		case "DA": return {220,20,60};	//Rojo
		case "DC": return {154,205,50};	//verde
		case "DG": return {75,0,130};	//morado
		case "DT": return {30,144,255};	//azul


		//Ribonucleótidos
		case "A": return {160,160,255};
		case "C": return {255,140,75};
		case "G": return {255,112,112};
		case "U": return {255,128,128};
		case "I": return {128,255,255};
		case "T": return {160,255,150};

		default: return {150,150,150};		//Heterógenos. Gris. También para elementos no estándar encontrados en solitario (como el Cobre).
	}
}




/********** getElementsNiceNames() **********/
/*
Description: Previamente obtenía un vector lleno de nombres
Date: Creation: May 4 2015.  
*/
global proc string getElementsNiceNames(string $shortName){
	switch($shortName){
		case "H": return "H - Hydrogen"; break;
		case "HE": return "He - Helium"; break;
		case "LI": return "Li - Lithium"; break;
		case "BE": return "Be - Beryllium"; break;
		case "B": return "B - Boron"; break;
		case "C": return "C - Carbon"; break;
		case "N": return "N - Nitrogen"; break;
		case "O": return "O - Oxygen"; break;
		case "F": return "F - Fluorine"; break;
		case "NE": return "Ne - Neon"; break;
		case "NA": return "Na - Sodium"; break;
		case "MG": return "Mg - Magnesium"; break;
		case "AL": return "Al - Aluminum"; break;
		case "SI": return "Si - Silicon"; break;
		case "P": return "P - Phosphorus"; break;
		case "S": return "S - Sulphur"; break;
		case "CL": return "Cl - Chlorine"; break;
		case "AR": return "Ar - Argon"; break;
		case "K": return "K - Potasium"; break;
		case "CA": return "Ca - Calcium"; break;
		case "SC": return "Sc - Scandium"; break;
		case "TI": return "Ti - Titanium"; break;
		case "V": return "V - Vanadium"; break;
		case "CR": return "Cr - Chromium"; break;
		case "MN": return "Mn - Manganese"; break;
		case "FE": return "Fe - Iron"; break;
		case "CO": return "Co - Cobalt"; break;
		case "NI": return "Ni - Nickel"; break;
		case "CU": return "Cu - Copper"; break;
		case "ZN": return "Zn - Zinc"; break;
		case "GA": return "Ga - Gallium"; break;
		case "GE": return "Ge - Germanium"; break;
		case "AS": return "As - Arsenic"; break;
		case "SE": return "Se - Selenium"; break;
		case "BR": return "Br - Bromine"; break;
		case "KR": return "Kr - Krypton"; break;
		case "RB": return "Rb - Rubidium"; break;
		case "SR": return "Sr - Strontium"; break;
		case "Y": return "Y - Yttrium"; break;
		case "ZR": return "Zr - Zirconium"; break;
		case "NB": return "Nb - Niobium"; break;
		case "MO": return "Mo - Molybdenum"; break;
		case "TC": return "Tc - Technetium"; break;
		case "RU": return "Ru - Ruthenium"; break;
		case "RH": return "Rh - Rhodium"; break;
		case "PD": return "Pd - Palladium"; break;
		case "AG": return "Ag - Silver"; break;
		case "CD": return "Cd - Cadmium"; break;
		case "IN": return "In - Indium"; break;
		case "SN": return "Sn - Tin"; break;
		case "SB": return "Sb - Antimony"; break;
		case "TE": return "Te - Tellurium"; break;
		case "I": return "I - Iodine"; break;
		case "XE": return "Xe - Xenon"; break;
		case "CS": return "Cs - Cesium"; break;
		case "BA": return "Ba - Barium"; break;
		case "HF": return "Hf - Hafnium"; break;
		case "TA": return "Ta - Tantalum"; break;
		case "W": return "W - Tungsten"; break;
		case "RE": return "Re - Rhenium"; break;
		case "OS": return "Os - Osmium"; break;
		case "IR": return "Ir - Iridium"; break;
		case "PT": return "Pt - Platinum"; break;
		case "AU": return "Au - Gold"; break;
		case "HG": return "Hg - Mercury"; break;
		case "TL": return "Tl - Thallium"; break;
		case "PB": return "Pb - Lead"; break;
		case "BI": return "Bi - Bismuth"; break;
		case "PO": return "Po - Polonium"; break;
		case "AT": return "At - Astatine"; break;
		case "RN": return "Rn - Radon"; break;
		case "FR": return "Fr - Francium"; break;
		case "RA": return "Ra - Radium"; break;
		case "AC": return "Ac - Actinium"; break;
		case "TH": return "Th - Thorium"; break;
		case "PA": return "Pa - Protactinium"; break;
		case "U": return "U - Uranium"; break;
		case "NP": return "Np - Neptunium"; break;
		case "PU": return "Pu - Plutonium"; break;
		case "AM": return "Am - Americium"; break;
		case "CM": return "Cm - Curium"; break;
		case "BK": return "Bk - Berkelium"; break;
		case "CF": return "Cf - Californium"; break;
		case "ES": return "Es - Einsteinium"; break;
		case "FM": return "Fm - Fermium"; break;
		case "MD": return "Md - Mendelevium"; break;
		case "NO": return "No - Nobelium"; break;
		case "LR": return "Lr - Lawrencium"; break;
		case "RF": return "Rf - Rutherfordium"; break;
		case "DB": return "Db - Dubnium"; break;
		case "SG": return "Sg - Seaborgium"; break;
		case "BH": return "Bh - Bohrium"; break;
		case "HS": return "Hs - Hassium"; break;
		case "MT": return "Mt - Meitnerium"; break;
		case "DS": return "Ds - Darmstadtium"; break;
		case "RG": return "Rg - Roentgenium"; break;
		case "CN": return "Cn - Copernicium"; break;
		case "UUT": return "Uut - Ununtrium"; break;
		case "FL": return "Fl - Flerovium"; break;
		case "UUP": return "Uup - Ununpentium"; break;
		case "UUS": return "Uus - Ununseptium"; break;				
		case "UUO": return "Uuo - Ununoctium"; break;

	}
}





/********** getResiduesNiceNames() **********/
/*
Antes era un vector, para recibirlos e imprimirlos en la terminal directamente.
			Sólo sirve para aminoácidos estándar.
Description: 
Date: Creation: May 4 2015.  
*/
global proc string getResiduesNiceNames(string $shortName){
	string $niceName ;
			switch($shortName){
				//Aminoácidos
				case "ALA": $niceName = "Alanine"; break;
				case "ARG": $niceName = "Arginine"; break;
				case "ASN": $niceName = "Asparagine"; break;
				case "ASP": $niceName = "Aspartic Acid"; break;
				case "CYS": $niceName = "Cysteine"; break;
				case "GLU": $niceName = "Glutamic Acid"; break;
				case "GLN": $niceName = "Glutamine"; break;
				case "GLY": $niceName = "Glycine"; break;
				case "HIS": $niceName = "Histidine"; break;
				case "ILE": $niceName = "Isoleucine"; break;
				case "LEU": $niceName = "Leucine"; break;
				case "LYS": $niceName = "Lysine"; break;
				case "MET": $niceName = "Methionine"; break;
				case "PHE": $niceName = "Phenylalanine"; break;
				case "PRO": $niceName = "Proline"; break;
				case "SEC": $niceName = "Serine"; break;
				case "SER": $niceName = "Serine"; break;
				case "THR": $niceName = "Threonine"; break;
				case "TRP": $niceName = "Tryptophan"; break;
				case "TYR": $niceName = "Tyrosine"; break;
				case "UNK": $niceName = "Unknown"; break;
				case "VAL": $niceName = "Valine"; break;
				case "HOH": $niceName = "Water"; break;



				//Deoxirribonucleótidos, DNA
				// Adenina, Guanina, Citosina y Timina
				case "DA": $niceName = "Adenine"; break;	
				case "DC": $niceName = "Cytosine"; break;
				case "DG": $niceName = "Guanine"; break;
				case "DT": $niceName = "Thymine"; break;
			}

	return $niceName;
}





global proc string getHelixesNiceTypes(int $helixNumber){
	switch($helixNumber){
		case 1 : return "Right-handed α"; break;
		case 2 : return "Right-handed ω"; break;
		case 3 : return "Right-handed π"; break;
		case 4 : return "Right-handed γ"; break;
		case 5 : return "Right-handed 3 - 10"; break;
		case 6 : return "Left-handed α"; break;
		case 7 : return "Left-handed ω"; break;
		case 8 : return "Left-handed γ"; break;
		case 9 : return "2 - 7 ribbon/helix"; break;
		case 10 : return "Polyproline"; break;
		default: return "Right-handed α";
	}
}




global proc int baseCount(string $base){
	global int $numbersOfBases[];

	if ($base == "DA"){
		return $numbersOfBases[0];
	} else if ($base == "DC"){
		return $numbersOfBases[1];
	} else if ($base == "DG"){
		return $numbersOfBases[2];
	} else if ($base == "DT"){
		return $numbersOfBases[3];
	}
}



/********** drawBallAndStick() **********/
/*
Description: Dibuja los enlaces entre los átomos de la molécula.

	Date: Creation and initial development of the ATOM module: May 7 2015.  

	Date: Creation of the HETATM module: June 29 2015.

	Date: Finish of the HETATM module: June 30 2015.

	Date: Second take on the ATOM module: July 1 2015.

	Date: Finish of the ATOM module: July 7 2015.

	Date: Starting to add the Nucleotides module: July 15 2015.

	Date: Finish of the Nucleotides module: July 16 2015.

	Notas: Al intentar dibujar sólo los modos de atom o de hetatm, me di cuenta de que los CONECT dan mucha información sobre
	los enlaces de los no heterógenos con los estándar, por eso a veces llevan información redundante, lo que hace que no pueda
	hacer el modo de dibujado ball & stick de cada modo como tenía pensado. Cambiaré el nombre de cada esfera, teniendo en cuenta
	si en el PDB es atom o hetatm.


	Modes: { full, atom, hetatm }
	Predeterminado: hetatm


*/

global proc drawBallAndStick(string $mode){
	global string $atomNames[];
	global string $recordTypes[];
	global string $residueNames[];
	global int $residueNumbers[];
	global string $chains[];
	global string $elements[];
	global int $atomConnections[];
	global int $numConect;
	global int $numBonds;
	global int $numberOfHeterogens;	//Número de HETATM



	global int $isBallAndStickFull;



	//Mensajes de error si no hay ningún hetatm
	if ($numberOfHeterogens == 0 && $mode == "hetatm"){
		print("No hay átomos heterógenos en la molécula.");
	}



	//Si ya se ha procesado, sólo se procede a esconder o mostrar los objetos adecuados

	if ($isBallAndStickFull == 0){


												/*********** HETATM ***********/ 

		if ($mode == "hetatm"){
			if ($numConect > 0){	//Hay conexiones de heterógenos (CONECT)
				int $source = $atomConnections[0];
				//print("source: "+$source+"\n");

				for ($i=1; $i<size($atomConnections); $i++){
					if (($atomConnections[$i] == 0) && ($i < size($atomConnections))){	//Cuando se encuentra un 0, que no sea el último, actualiza $source
						$source = $atomConnections[$i+1];
					} else if (($source != $atomConnections[$i]) &&  ($source < $atomConnections[$i])){	//Para evitar dibujar: 1, conexiones a sí mismo y 2, conexiones ya dibujadas (para no repetirlas)
						drawBond($source, $atomConnections[$i]);
						$numBonds++;
					}
				}//fin for HETATM
			}	

			$isBallAndStickFull = 0;

		}







												/*********** ATOM ***********/ 

		else if ($mode == "atom"){
			int $N, $C, $CA, $CB, $CG, $CD, $CE, $CZ, $SG, $O;
			int $P, $O5p, $C5p, $C4p, $O4p, $C3p, $O3p, $C2p, $C1p, $C2, $C4, $C5, $C6, $C8, $O6, $N1, $N2, $N3, $N7, $N9;
			int $contSG = 1;														
			//Hay que guardarlo para conectar residuos entre sí


			for ($a=1; $a<=size($atomNames); $a++){

				if (size($residueNames[$a]) == 3){


														/***** Aminoácidos *****/
														//CIS, TYR, ARG...


					if ($recordTypes[$a] == "ATOM"){	
						if ($atomNames[$a] == "N" || $atomNames[$a] == "CA" || $atomNames[$a] == "C" || $atomNames[$a] == "O"){
							if ($atomNames[$a] != "O"){
								drawBond($a, $a+1);	$numBonds++;
							}



														/**** Primary chain ****/

							if ($atomNames[$a] == "N"){
								$N = $a;
								if ( $recordTypes[$a-1] != "TER" && $a != 1 && $residueNames[$a] != "CYS"){	//CYS. REVISAR.
									//Si justo antes de él no hay un TER, habrá que conectarlo a un C
									//Conecta el N actual con su C anterior
									if ($recordTypes[$C] == $recordTypes[$a]){
										drawBond($a, $C);	$numBonds++;	
									}
								}
							} else if ($atomNames[$a] == "C"){
								$C = $a;
							} else if ($atomNames[$a] == "CA"){
								$CA = $a;
							}



														/**** Secondary chain ****/
						} else if ($atomNames[$a] == "CB"){
								$CB = $a;
								drawBond($a, $CA);	$numBonds++;
							} else if ($atomNames[$a] == "CG"){
								$CG = $a; 
								drawBond($a, $CB);	$numBonds++;
							} else if ($atomNames[$a] == "CD"){
								$CD = $a;
										if ($residueNames[$a] == "PRO"){			//Caso especial: CD->N
											drawBond($a, $N);	$numBonds++; 
											drawBond($a, $CG);	$numBonds++;
										} else {			//Caso especial: CD->N
											drawBond($a, $CG);	$numBonds++; 
										}
							} else if ($atomNames[$a] == "CE"){
								$CE = $a;
										if ($residueNames[$a] == "MET"){			//CE->SD
											drawBond($a, $a-1);	$numBonds++;
										} else {
											drawBond($a, $CD);	$numBonds++;
										}
							} else if ($atomNames[$a] == "CZ"){
								$CZ = $a;
										if ($residueNames[$a] == "PHE"){			//CZ->(CE1, CE2)
											drawBond($a, $a-1);	$numBonds++;
											drawBond($a, $a-2);	$numBonds++;
										} else if ($residueNames[$a] == "ARG"){		//ARG: CZ->(NE, NH1, NH2);
											drawBond($a, $a-1);	$numBonds++;
											drawBond($a, $a+1);	$numBonds++;
											drawBond($a, $a+2);	$numBonds++;
										} else if ($residueNames[$a] == "TYR"){		//TYR: CZ->(CE1, CE2, OH);
											drawBond($a, $a-1);	$numBonds++;
											drawBond($a, $a-2);	$numBonds++;
											drawBond($a, $a+1);	$numBonds++;
										}
							} else if ($atomNames[$a] == "OG"){
								drawBond($a, $CB);	$numBonds++;
							} else if ($atomNames[$a] == "SD"){
								drawBond($a, $CG);	$numBonds++;
							} else if ($atomNames[$a] == "NZ"){
								drawBond($a, $CE);	$numBonds++;
							} else if ($atomNames[$a] == "NE"){
								drawBond($a, $CD);	$numBonds++;					
							} else if ($atomNames[$a] == "CG1" || $atomNames[$a] == "CG2" || $atomNames[$a] == "OG1"){
								drawBond($a, $CB);	$numBonds++;
							} else if ($atomNames[$a] == "CD1" || $atomNames[$a] == "CD2"){
										if ($residueNames[$a] == "LEU" || $residueNames[$a] == "PHE" || $residueNames[$a] == "TYR" || $residueNames[$a] == "TRP" || $residueNames[$a] == "HIS"){
											drawBond($a, $CG);	$numBonds++;
										} else if ($residueNames[$a] == "ILE"){			//CD1->CG1
											drawBond($a, $a-2);	$numBonds++;
										}
							} else if ($atomNames[$a] == "CE1"){
							 			if ($residueNames[$a] == "PHE" || $residueNames[$a] == "TYR"){		//CE1->CD1
							 				drawBond($a, $a-2);	$numBonds++;
							 			}
							} else if ($atomNames[$a] == "CE2"){
							 			if ($residueNames[$a] == "PHE" || $residueNames[$a] == "TYR"){		//CE1->CD1
							 				drawBond($a, $a-2);	$numBonds++;
							 			} else if ($residueNames[$a] == "TRP"){
							 				drawBond($a, $a-1);	$numBonds++;
							 				drawBond($a, $a-2);	$numBonds++;
							 				drawBond($a, $a+2);	$numBonds++;
							 			}
							} else if ($atomNames[$a] == "CE3"){
				 				drawBond($a, $a-3);	$numBonds++;	//CD2	
				 				drawBond($a, $a+2);	$numBonds++;	//CZ3	
							} else if ($atomNames[$a] == "CZ2"){
								drawBond($a, $a+2);	$numBonds++;	//CH2
							} else if ($atomNames[$a] == "CZ3"){
								drawBond($a, $a+1); $numBonds++;	//CH2
							} else if ($atomNames[$a] == "NE1"){
								drawBond($a, $a-2);	$numBonds++;
							} else if ($atomNames[$a] == "NE2"){
									if ($residueNames[$a] == "HIS"){
										drawBond($a, $a-1);	$numBonds++;
										drawBond($a, $a-2);	$numBonds++;	
									} else if ($residueNames[$a] == "GLN"){
										drawBond($a, $CD);	$numBonds++;
									}
							} else if ($atomNames[$a] == "ND1"){
								drawBond($a, $CG);	$numBonds++;
								drawBond($a, $a+2);	$numBonds++; 	//CE1
							} else if ($atomNames[$a] == "ND2"){
								drawBond($a, $CG);	$numBonds++;
							} else if ($atomNames[$a] == "OD1" || $atomNames[$a] == "OD2"){
								drawBond($a, $CG);	$numBonds++;
							} else if ($atomNames[$a] == "OE1" || $atomNames[$a] == "OE2"){
								drawBond($a, $CD);	$numBonds++;
						} else if ($atomNames[$a] == "OXT"){
							drawBond($a, $C);	$numBonds++;
						}




					//Conexión de HETATM con su ATOM previo, de forma N->C
					} else if ($recordTypes[$a] == "HETATM"  && $atomNames[$a] == "N" && $recordTypes[$a-1] != "TER" && $recordTypes[$a-1] != ""){
						$N = $a;
						if ($recordTypes[$a] == $recordTypes[$C]){
							drawBond($a, $C);	$numBonds++;
						}
					} else if ($recordTypes[$a] == "HETATM"  && $atomNames[$a] == "C"){
						$C = $a;
					//Conexión de hidrógenos y oxígenos
					} else if ($recordTypes[$a] == "HETATM" && $residueNames[$a] == "HOH" && $atomNames[$a] == "O"){
						$O = $a;
					} else if ($recordTypes[$a] == "HETATM" && $residueNames[$a] == "HOH" && $elements[$a] == "H"){
						drawBond($a, $O);	//$numBonds++;
					}






				} else if ($recordTypes[$a] != "HETATM" && size($residueNames[$a]) == 2){


													/***** Nucleótidos *****/
													//DT, DA, DG, DC

					if (($atomNames[$a] == "P") && ($residueNumbers[$a] != $residueNumbers[$a-1])){
						$P = $a;

						if ($chains[$P] == $chains[$a]){
							drawBond($a, $O3p); $numBonds++;
						}

					} else if ($atomNames[$a] == "O5'"){
						$O5p = $a;
						//print($a+": a\n");

						if (($P != 0) && ($a != 0) && ($chains[$P] == $chains[$a])){
							drawBond($a, $P); $numBonds++;	//O5'-P
						}
					} else if ($atomNames[$a] == "OP1" || $atomNames[$a] == "OP2"){
						drawBond($a, $P); $numBonds++;
					} else if ($atomNames[$a] == "C5'"){
						$C5p = $a;
						drawBond($a, $O5p);	$numBonds++;	//C5'-O5'
					} else if ($atomNames[$a] == "C4'"){
						$C4p = $a;
						drawBond($a, $C5p);
					} else if ($atomNames[$a] == "O4'"){
						$O4p = $a;
						drawBond($a, $C4p); $numBonds++; 	//O4'-C4'
					} else if ($atomNames[$a] == "C3'"){
						$C3p = $a;
						drawBond($a, $C4p); $numBonds++;	//C3'-C4'
					} else if ($atomNames[$a] == "O3'"){
						$O3p = $a;
						drawBond($a, $C3p); $numBonds++; 	//C3'-O3'
					} else if ($atomNames[$a] == "C2'"){
						$C2p = $a;
						drawBond($a, $C3p);	$numBonds++; 	//C2'-C3'
					} else if ($atomNames[$a] == "C1'"){	
						$C1p = $a;
						drawBond($a, $C2p);	$numBonds++;	//C1'-C2' 
						drawBond($a, $O4p); $numBonds++;	//C1'-O4'
					} else if ($atomNames[$a] == "N9"){
						$N9 = $a;
						drawBond($a, $C1p); $numBonds++; 	//N9-C1'
					} else if ($atomNames[$a] == "C8"){
						$C8 = $a;
						drawBond($a, $N9);	$numBonds++; 	//C8-N9
					} else if ($atomNames[$a] == "N7"){
						$N7 = $a;
						drawBond($a, $C8); $numBonds++;		//N7-C8


					} else if ($atomNames[$a] == "C4"){
						$C4 = $a;						

						if ($residueNames[$a] == "DG" || $residueNames[$a] == "DA"){	//C4->C5
							drawBond($a, $N9); $numBonds++;
							drawBond($a, $N3); $numBonds++;
							drawBond($a, $C5); $numBonds++;
						} else if ($residueNames[$a] == "DT" || $residueNames[$a] == "DC"){	
							drawBond($a, $N3); $numBonds++;
						}

					} else if ($atomNames[$a] == "C5"){
						$C5 = $a;
							if ($residueNames[$a] == "DG" || $residueNames[$a] == "DA"){
								drawBond($a, $N7); $numBonds++;	//C5-N7

							} else if ($residueNames[$a] == "DT" || $residueNames[$a] == "DC"){	//C5->C4
								drawBond($a, $C4); $numBonds++; 
							}


					} else if ($atomNames[$a] == "C6"){
						$C6 = $a;
						if ($residueNames[$a] == "DT" || $residueNames[$a] == "DC"){
							drawBond($a, $N1);	$numBonds++;//C6-N1
						}
						drawBond($a, $C5); $numBonds++;		//C6-C5
					} else if ($atomNames[$a] == "O6"){		//O6-C6;
						$O6 = $a;
						drawBond($a, $C6); $numBonds++; 
					} else if ($atomNames[$a] == "N6"){		//N6-C6, NA
						drawBond($a, $C6); $numBonds++;
					} else if ($atomNames[$a] == "N1"){
						$N1 = $a;
						if ($residueNames[$a] == "DT" || $residueNames[$a] == "DC"){
							drawBond($a, $C1p);	$numBonds++;//N1-C1'
						} else if ($residueNames[$a] == "DA" || $residueNames[$a] == "DG"){
							drawBond($a, $C6);	$numBonds++;//C6-N1
						}
					} else if ($atomNames[$a] == "C2"){
						$C2 = $a;		
						drawBond($a, $N1); $numBonds++;		//C2-N1
					} else if ($atomNames[$a] == "N2"){
						$N2 = $a;
						drawBond($a, $C2); $numBonds++;		//N2-C2
					} else if ($atomNames[$a] == "N3"){
						$N3 = $a;
						drawBond($a, $C2); $numBonds++;		//N3-C2
					} else if ($atomNames[$a] == "O4"){
						drawBond($a, $C4); $numBonds++;		//O4-C4
					} else if ($atomNames[$a] == "O2"){
						drawBond($a, $C2); $numBonds++;		//O2-C2
					} else if ($atomNames[$a] == "C7"){
						drawBond($a, $C5); $numBonds++;		//C7-C5
					} else if ($atomNames[$a] == "N4"){
						drawBond($a,$C4); $numBonds++; 		//N4-C4
					}

				}//fin if-else residueNames[$a]
			}//fin for ATOM


			//Si los ATOM se han calculado, es que los HETATM también estaban anteriormente calculados, por ello:
			$isBallAndStickFull = 1;
			//Después se esconden las partes necesarias dependiendo del modo que se especificara
			//Si modo == full, no se hace nada.
		}
		


		//print("\nFin de dibujado de enlaces");

	}//fin isballandstickfull










	if ($mode == "atom"){
		/*select -r hetatm_CG_25_1 ;
		select -r hetatm_C_bond_25_to_27_A ;
		select -r hetatm_backbone_C_bond_403_to_404_C ;*/

		showBonds(1);
		showAllAtoms(1);
		showAllChainTraces(0);
		showHelixes(0);
		showSheets(0);

		print("\nNúmero de enlaces: "+$numBonds+"\n\n\n");

	} else if ($mode == "hetatm"){
		showAllAtoms(0);
		showBonds(0);



		if ($numberOfHeterogens > 0){
			showBonds(0);	//select -r C_bond_229_to_228_B ;

			string $hetBonds[] = `ls "hetatm_*_bond*"`;
			if (size($hetBonds) > 0) showHidden $hetBonds;
			showConects("*",0);			
			showHetatms(1);
		}
	} 

}//fin drawBallAndStick








// /********** drawSphereFromId() **********/

// global proc drawSphereFromId(int $a, float $radius){
// 	//Se colorea del color dado por su elemento automáticamente
// 	global string $elements[];
// 	global string $recordTypes[];
// 	global string $atomNames[];
// 	global vector $coordinates[];				//Array de vectores (triplets of X, Y, Z), $xyzArray[] <<X, Y, Z>>


// 	string $element = $elements[$a];
// 	string $atomName = $atomNames[$a]+"_BS";
// 	vector $position = $coordinates[$a];
// 	float $x = $position.x;
// 	float $y = $position.y;
// 	float $z = $position.z;
// 	string $shaderName = ($element)+"_Shader";
// 	//float $radius = 0.4;
// 	float $data[] = getCPKProperties($element);	//Original y que va bien
// 	//$data[0] = $radius; //Se cambia el radio, de ser el definido por el elemento, a uno constante
// 	float $color[] = { $data[1], $data[2], $data[3] };

// 	string $atomNodeName[] = `sphere -radius $radius -name $atomName`;
// 	move -ws $x $y $z $atomNodeName[0];

// 	assignShader($shaderName, $color, $atomNodeName[0]);
// }








/********** drawCylinder() **********/
/*
Description: Dibuja la conexión entre dos átomos, siendo ésta uno o dos cilindros, cada uno de ellos pintado del color
	del átomo de origen.
Addition date of the assignShader module: July 4 2015.
Addition date of the DNA module: July 17 2015.
Refinement of the DNA module: August 18 2015.


TODOS LOS BONDS: "*bond*"

	-	CA_bond_123_to_124_A : 				ATOM <-> ATOM
	-	hetatm_CA_bond_123_to_124_A :		HETATM <-> HETATM
	-	conects_CA_bond_123_to_124_A : 		ATOM <-> HETATM

	-	backbone_C_bond_123_to_124_A : 		Backbone
	-	backboneO_O_bond_123_to_124_A : 	Backbone Oxygen
	-	backboneSC_CA_bond_123_to_124_A : 	Backbone Side Chain

*/

global proc drawCylinder(vector $coordA, vector $coordB, string $element, int $nA, int $nB, string $mode, int $p){
	global string $recordTypes[];
	global string $residueNames[];
	global string $chains[];
	global string $atomNames[];
	global int $isThereDNA;
	global int $dnaStrand1[];



	string $nameA = $atomNames[$nA];
	string $nameB = $atomNames[$nB];
	string $residue = $residueNames[$nA];

	int $isBackbone = 0;		//DNA y Amino
	int $isBackboneOxigen = 0;	//Amino
	int $isBackboneSC = 0;		//DNA
	int $isHETATM = 0;
	int $conectsAtomAndHetatm = 0;


	float $color[];
	string $shaderName = $element+"_Shader";




	if (size($residueNames[$nA]) == 2){
												/* DNA */

		// Minimal ADN: {P, O3', O5', C3', C4', C5'}
		// FULL ADN: { MINIMAL + C1', C2', O4'}

		if (($nameA == "O3'" || $nameB == "O3'") && ($nameA == "C3'" || $nameB == "C3'"))	$isBackbone = 1;
		else if (($nameA == "C3'" || $nameB == "C3'") && ($nameA == "C4'" || $nameB == "C4'"))	$isBackbone = 1;
		else if (($nameA == "C4'" || $nameB == "C4'") && ($nameA == "C5'" || $nameB == "C5'"))	$isBackbone = 1;
		else if (($nameA == "C5'" || $nameB == "C5'") && ($nameA == "O5'" || $nameB == "O5'"))	$isBackbone = 1;
		else if (($nameA == "O5'" || $nameB == "O5'") && ($nameA == "P" || $nameB == "P"))	$isBackbone = 1;
		else if (($nameA == "P" || $nameB == "P") && ($nameA == "O3'" || $nameB == "O3'"))	$isBackbone = 1;
		else $isBackbone = 0;


		if (($nameA == "C3'" || $nameB == "C3'") && ($nameA == "C2'" || $nameB == "C2'"))	$isBackboneSC = 1;
		else if (($nameA == "C2'" || $nameB == "C2'") && ($nameA == "C1'" || $nameB == "C1'"))	$isBackboneSC = 1;
		else if (($nameA == "C1'" || $nameB == "C1'") && ($nameA == "O4'" || $nameB == "O4'"))	$isBackboneSC = 1;
		else if (($nameA == "O4'" || $nameB == "O4'") && ($nameA == "C4'" || $nameB == "C4'"))	$isBackboneSC = 1;
		else $isBackboneSC = 0;

	} else {
												/* Aminos */

		if (($nameA == "N" || $nameB == "N") && ($nameA == "CA" || $nameB == "CA"))	$isBackbone = 1;
		else if (($nameA == "CA" || $nameB == "CA") && ($nameA == "C" || $nameB == "C")) $isBackbone = 1;
		else if (($nameA == "C" || $nameB == "C") && ($nameA == "N" || $nameB == "N")) $isBackbone = 1;
		else $isBackbone = 0;

		if ($nameA == "O" || $nameB == "O")	$isBackboneOxigen = 1;
		else $isBackboneOxigen = 0;	

		/*Algunos residuos sí tienen su nombre de residuo con un tamaño mayor a 3. Estos son los del código de residuos.
		Ejemplo: Nucleótidos N
		*/


												/* Is HETATM? */

		if ($recordTypes[$nA] == "HETATM"){
			$isHETATM = 1;
		}


												/* conects_ */

		//Operaciones necesarias para la clasificación de los enlaces, para saber posteriormente si pertenecen a la backbone o a un hetatm, etc.
		//Los nombres de algunos HETATM pueden ser C1, C2... Ejemplo: Hidrolasa.

		if 	( ($recordTypes[$nA] == "HETATM" ) && ($recordTypes[$nB] == "ATOM" ) ){
			$conectsAtomAndHetatm = 1;
		} else if ( ($recordTypes[$nB] == "HETATM" ) && ($recordTypes[$nA] == "ATOM" ) ){
			$conectsAtomAndHetatm = 1;
		} 

		//Para renombrar las conexiones. La conexión entre el N y el C entre un ATOM y un HETATM no debe verse ni en modo
		//"atom" ni en modo "hetatm". Por ello siempre tienen que quitarse. También habría quedarles otro nombre.
		//atHetConection. Siguen formando parte de la BACKBONE general. 
		// Ejemplo: 
		//		select -r hetatm_backbone_N_bond_39_to_34_A ; 
		//		select -r backbone_C_bond_34_to_39_A ;

	}








												/* Dibujado */

	if ($nA != 0 && $nB != 0){
		//curve1
		string $curve1 = "cylinderCurve1_"+$nA+"_to_"+$nB;
		//Creación de la primera curva que une ambas coordenadas
		curve -d 1 -p ($coordA.x) ($coordA.y) ($coordA.z) -p ($coordB.x) ($coordB.y) ($coordB.z) -k 0 -k 1 -name $curve1;
		//setAttr ($curve1+".scaleY") 0.8;
		move ($coordA.x) ($coordA.y) ($coordA.z) ($curve1 + ".scalePivot") ($curve1 + ".rotatePivot") ;







		//Renombramientos. Dependiendo del modo, ponerlo como base o bond
		string $nameCylinderFinal;
		if ($mode == "ballandstick"){
			if ($isBackbone == 1){
				$nameCylinderFinal = "backbone_"+$element+"_bond_"+$nA+"_to_"+$nB+"_"+$residue+"_"+$chains[$nA];
			} else if ($isBackboneOxigen == 1){
				$nameCylinderFinal = "backboneO_"+$element+"_bond_"+$nA+"_to_"+$nB+"_"+$residue+"_"+$chains[$nA];
			} else {
				$nameCylinderFinal = $element+"_bond_"+$nA+"_to_"+$nB+"_"+$residue+"_"+$chains[$nA];
				// CE1_bond_123_to_124_TYR_A
			}



			if ($isHETATM == 1){
				$nameCylinderFinal = "hetatm_"+$nameCylinderFinal;
			}


			//Nombre especial para los bonds que unen un átomo ATOM y otro HETATM
			if ($conectsAtomAndHetatm == 1){
				$nameCylinderFinal = "conects_"+$nameCylinderFinal;
			}






		} else if ($mode == "dna" || $mode == "slabs"){
			string $atom = $nameA;

			//Modificar $atom si fuera necesario
			if (size($atom) == 3 && $atom != "OP1" && $atom != "OP2"){
				//Hay que renombrarlo, ya que el apóstrofe no lo acepta bien Maya
				$atom = `substring $nameA 1 2`;
				$atom = $atom + "_";	// O3' -> O3_
			}


			if ($mode == "dna"){
				if ($isBackboneSC == 1){
					$nameCylinderFinal = "backboneSC_"+$atom+"_bond_"+$nA+"_to_"+$nB+"_"+$chains[$nA];
				} else if ($isBackbone == 1){
					$nameCylinderFinal = "backbone_"+$atom+"_bond_"+$nA+"_to_"+$nB+"_"+$chains[$nA];
				} else {
					$nameCylinderFinal = $residue+"_base_bond_"+$nA+"_to_"+$nB+"_"+$residue+"_"+$chains[$nA];	
					// O3__bond_123_to_124_TYR_A
				}



			} else if ($mode == "slabs"){	
				$nameCylinderFinal = $residue+"_slab_"+$nA+"_to_"+$nB+"_"+$chains[$nA];	
				// DG_slab_186_to_288_A ;
			}

		}









		//Creación del cilindro, girarlo 90º y borrar todas sus caras excepto una tapa
		string $names[];
		if ($mode == "ballandstick"){	
			$names = ` polyCylinder -ch on -o on -r 0.2 -h 0.456119 -sa 18 -sc 1 -cuv 3 `;
			rename $names[1] ("polyCylinder_"+$nameCylinderFinal);
		} else if ($mode == "dna" || $mode == "slabs"){
			$names = ` polyCylinder -ch on -o on -r 0.2 -h 0.456119  -sa 18 -sc 1 -cuv 3 `;
			rename $names[1] ("polyCylinder_"+$nameCylinderFinal);
		} 









		//Preparación de la tapa de cilindro para su extrusión
		$group = `ls -sl`;
		string $nameCylinder = $group[0];
		rotate -r -os 90 0 0 $nameCylinder;
		select -toggle $nameCylinder.f[0:35]; //toggle: vacía la 'cola' de selección y añade los elementos nuevos
		doDelete;
		// select -toggle $nameCylinder;
		// select -r $nameCylinder;
		//Cambiar el pivot hasta el punto de la circunferencia, para realizar con exactitud las transformaciones posteriores
		move 0 0 0.22806 ($nameCylinder + ".scalePivot") ($nameCylinder + ".rotatePivot") ;
		move -rpr 0 0 0 ;

		//Mover hasta hasta el punto1
		setPosition($nameCylinder, $coordA);

		extrudeCylinder($curve1, $nameCylinder, $mode);


		select -r ($nameCylinder + ".f[18:35]");
		doDelete;
		select -r ($nameCylinder + ".f[18:35]");
		doDelete;


		//curve2
		string $curve2 = "cylinderCurve2_"+$nA+"_to_"+$nB;
		//Crear de la segunda curva que une ambas coordenadas, para volver a barrerla posteriormente y ajustar el cilindro
		curve -d 1 -p ($coordB.x) ($coordB.y) ($coordB.z) -p ($coordA.x) ($coordA.y) ($coordA.z) -k 0 -k 1 -name $curve2;
		//setAttr ($curve2+".scaleY") 0.8;
		//Poner su pivot en el punto 2
		//move ($coordB.x) ($coordB.y) ($coordB.z) ($curve2 + ".scalePivot") ($curve2 + ".rotatePivot") ;




		extrudeCylinder($curve2, $nameCylinder, $mode);






		if ($mode == "dna"){
			int $s = (size($dnaStrand1)-1);

			if ($p == 0 || $p == $s){
				setAttr ($nameCylinder + ".scaleX") 1.1;
				setAttr ($nameCylinder + ".scaleY") 1.1;
				setAttr ($nameCylinder + ".scaleZ") 1.1;
			}
			//$isThereDNA = 1;
		}




		//Se le cambia el nombre al cilindro final
		rename $nameCylinder $nameCylinderFinal;


		

		//Añadir a su grupo correspondiente
		parent $nameCylinderFinal "Bonds";
		parent $curve1 "Curves";
		parent $curve2 "Curves";




		//Adición del shader del cilindro, de su color correspondiente
		//Usamos funciones distintas si es un aminoácido y si es ADN
		if (size($residueNames[$nA]) == 3){					//Aminoácido
			$color = getCPKProperties($element);
			assignShader($shaderName, $color, $nameCylinderFinal);
			//assignExistingShader($shaderName, $nameCylinderFinal);
		} else if (size($residueNames[$nA]) == 2){			//ADN
			$color = getCPKResidueProperties($element);
			assignShader($shaderName, $color, $nameCylinderFinal);
		}	
	}
}








/********** drawBond() **********/
/*
Description: Dibuja la conexión entre dos átomos, siendo ésta uno o dos cilindros, cada uno de ellos pintado del color
	del átomo de origen.
Date: Creation: May 7 2015.  
Date: Finish: May 9 2015.
Addition date of the drawCylinder module: July 4 2015.
*/

global proc drawBond(int $nA, int $nB){
	//Hacer que se compruebe el elemento de cada lado y subdividir el cilindro si son elementos distintos
	global vector $coordinates[];
	global string $elements[];	
	global string $residueNames[];


	/***************/
	string $mode;
	/***************/


	vector $coordA, $coordB;
	string $elementA, $elementB;
	global string $cylinderGroupName;
	string $curve1, $curve2, $nameCylinder;
	string $group[];
	string $nodeName[];

	
	if (size($residueNames[$nA]) == 2){	
		$mode = "dna";
	} else {
		$mode = "ballandstick";
	}



	$coordA = $coordinates[$nA];
	$coordB = $coordinates[$nB];

	$elementA = $elements[$nA];
	$elementB = $elements[$nB];



	if ($elementA == $elementB){
		//Se dibuja un sólo cilindro y las coordenadas de cada punto son las mismas
		drawCylinder($coordA, $coordB, $elementA, $nA, $nB, $mode, 1);
	} else {
		//Dibujar dos cilindros y cambiar los dos puntos 		
		//vector $midPoint = << ($coordA.x+$coordB.x)/2, ($coordA.y+$coordB.y)/2, ($coordA.z+$coordB.z)/2 >>;
		vector $midPoint = calculateMidPoint($coordA, $coordB);

		drawCylinder($midPoint, $coordA, $elementA, $nA, $nB, $mode, 1);
		drawCylinder($midPoint, $coordB, $elementB, $nB, $nA, $mode, 1);
	}
}









global proc drawCurve(int $curvePoints[], string $mode, int $number){
	global string $chains[];
	global vector $coordinates[];
	string $curve;



	if (size($curvePoints) > 0){
		int $a = $curvePoints[0];
		string $chainLetter = $chains[$a];			


		if ($mode == "smooth"){
			$curve = ("smoothMinimalChainTraceCurve_"+$number+$chainLetter);					//smoothChainTrace_A
			print("Smooth Minimal Cylinder Chain Trace: "+$curve+"\n");
		} else if ($mode == "regular"){
			$curve = ("regularMinimalChainTraceCurve_"+$number+$chainLetter);				//regularChainTrace_A
			print("Regular Minimal Cylinder Chain Trace "+$curve+"\n");
		} 
		


		for ($p=1; $p<size($curvePoints); $p++){	
			int $cp1 = $curvePoints[$p-1];
			int $cp2 = $curvePoints[$p];
			vector $point0 = $coordinates[$cp1];
			vector $point1 = $coordinates[$cp2];

			if ($p==1){
				curve -d 1 -p ($point0.x) ($point0.y) ($point0.z) -p ($point1.x) ($point1.y) ($point1.z) -name $curve -k 0 -k 1;
			} else {
				curve -append -p ($point1.x) ($point1.y) ($point1.z) $curve;	
			}
		}


		if (size($curvePoints) > 3 && $mode == "smooth"){
			rebuildCurve -ch 0 -rpo 1 -rt 0 -end 0 -kr 1 -kcp 1 -kep 0 -kt 0 -s 0 -d 3 -tol 5.77201e-06 $curve;	
			//Manteniendo los CVs y las tangentes finales
		} else if ($mode == "smooth"){
			rebuildCurve -ch 0 -rpo 1 -rt 0 -end 0 -kr 1 -kcp 0 -kep 0 -kt 0 -s 0 -d 3 -tol 5.77201e-06 $curve;	
			//No mantener los CVs
		}

		string $group[];
		string $cylinder;

		if ($mode == "smooth"){
			rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 1 -kep 1 -kt 0 -s 0 -d 3 -tol 5.77201e-06 $curve;	//Manteniendo los CVs y las tangentes finales
			$cylinder = ("smoothMinimalChainTrace_"+$number+$chainLetter);
			polyCylinder -ch on -o on -r 0.14 -h 0.456119 -sa 18 -sc 1 -cuv 3 -name $cylinder;			
		} else if ($mode == "regular"){
			$cylinder = ("regularMinimalChainTrace_"+$number+$chainLetter);
			polyCylinder -ch on -o on -r 0.14 -h 0.456119 -sa 18 -sc 1 -cuv 3 -name $cylinder;		
		}	



		rotate -r -os 90 0 0 ;
		select -toggle $cylinder.f[0:35];
		doDelete;
		select -toggle $cylinder;
		select -r $cylinder;	
		move 0 0 0.22806 ($cylinder + ".scalePivot") ($cylinder + ".rotatePivot") ;
		move -rpr 0 0 0 ;
		
		vector $firstCoord = $coordinates[$curvePoints[0]];
		setPosition($cylinder, $firstCoord);	// $uno = primera coordenada

		int $nPoints = size($curvePoints);
		extrudeRibbon($curve, $cylinder, $nPoints);
		

		string $shaderName = "chainTrace_Shader";
		float $color[] = {239,153,118};

		assignShader($shaderName, $color, $cylinder);
	}
}









/********** drawChainTrace()**********/

//Version: 1.0

//Date of start and finish: July 8 2015.

//Description: Cilindros rectos de CA en CA.
//Dibujados reutilizando la función para unir dos átomos.
// global proc drawChainTrace(){
// 	global string $atomNames[];
// 	global string $chains[];
// 	//Conexiones hechas de alante a atrás

// 	int $previous;

// 	for ($a=2; $a<=size($atomNames); $a++){	//Primer CA en posición 2
// 		if ($atomNames[$a] == "CA"){
// 			drawSphereFromId($a, 0.4);

// 			if ( ($chains[$previous] == $chains[$a]) && ($a != 2) ) {
// 				drawBond($a, $previous);
// 			}
// 			$previous = $a;			
// 		}
// 	}//fin for
// }



/********** drawChainTrace()**********/

//Version: 1.0
//Date of start: July 9 
//Date of finish: July 11

//Version: 2.0
//Date of start and finish: July 12

//Date of start of the Nucleotides module: July 17
//Date of finish of the Nucleotides module: July 18
//Mode size: 2

//Made using CA atoms

global proc drawChainTrace(string $modeAminoacids, string $modeDNA){	
	/*
	Mode Aminoacid: "smoothAminoacid", "regularAminoacid"
	Mode DNA: "roundedDNA", "edgedDNA", "flatDNA"
	*/

	global string $modeAminoacids;

	global string $atomNames[];
	global string $residueNames[];
	global string $chains[];
	global vector $coordinates[];
	global string $recordTypes[];

	global string $sceneNucleotides[];
	global string $sceneAminoAcids[];

	global int $dnaStrand1[];
	global int $dnaStrand2[];
	global int $sceneDnaStrands;

	global string $aminoChainTraceCurrentShape;
	global string $dnaChainTraceCurrentShape;


	global int $regularDrawn;
	global int $aminosDrawn;

	//




	int $curvePoints[];		//Vector de índices de puntos de la curva
	string $curve;
	int $currentStrand;
	vector $firstCoord;




	for ($a=2; $a<size($recordTypes); $a++){								//Primer CA en posición 2
		if ($atomNames[$a] == "CA" || $atomNames[$a] == "C4'"){
			//en realidad es con el C5'
			//Añadir punto a la curva
			if ($atomNames[$a] == "CA"){
				$curvePoints[size($curvePoints)] = $a;	
			} else if ($atomNames[$a] == "C4'"){
				//No lo guardo en $curvePoints, que se termina eliminando, sino en un vector de puntos de ADN que se guarda
				if (size($dnaStrand1) == 0){
					$dnaStrand1[size($dnaStrand1)] = $a;
				} else {
					if ($chains[$a] == $chains[$dnaStrand1[size($dnaStrand1)-1]]){
						//Si la cadena del actual es distinta del último elemento de $dnaStrand1, hay que guardarlo en $dnaStrand2
						$dnaStrand1[size($dnaStrand1)] = $a;
						$currentStrand = 1;
						//print($chains[$a]+"\n");
					} else {
						$dnaStrand2[size($dnaStrand2)] = $a;
						$currentStrand = 2;
					}
					//print ("current strand: "+$currentStrand+"\n");
				}
			}
		} else if ($recordTypes[$a] == "TER"){







											/********** Modo aminoácidos **********/


			if (size($curvePoints) > 0){
				//Ya hay una curva más, lista para ser dibujada
				string $chainLetter = $chains[$a];			


				if ($modeAminoacids == "smoothAminoacid"){
					$curve = ("smoothAminoacidChainTraceCurve_"+$chainLetter);					//smoothChainTrace_A
					//print("Smooth Cylinder Chain Trace: "+$curve+"\n");
					$aminoChainTraceCurrentShape = "smooth";
					$modeAminoacids = "smoothAminoacid";

				} else if ($modeAminoacids == "regularAminoacid"){
					$curve = ("regularAminoacidChainTraceCurve_"+$chainLetter);					//regularChainTrace_A
					//print("Regular CylinderChain Trace: "+$curve+"\n");
					$aminoChainTraceCurrentShape = "regular";
					$modeAminoacids = "regularAminoacid";
					$regularDrawn = 1;
				} 
				

				//print($curvePoints);
				//print("TER. Fin cadena\n");
				//Añadir a la curva cada uno de los puntos de $curvePoints

				for ($p=1; $p<size($curvePoints); $p++){	
					//Empiezo desde el punto 1 para añadir los puntos 0 y 1, ya que dos puntos son el mínimo para crear una curva.
					//Luego les añado el resto

					int $cp1 = $curvePoints[$p-1];
					int $cp2 = $curvePoints[$p];
					vector $point0 = $coordinates[$cp1];
					vector $point1 = $coordinates[$cp2];

					if ($p==1){
						//Se crea la curva
						curve -d 1 -p ($point0.x) ($point0.y) ($point0.z) -p ($point1.x) ($point1.y) ($point1.z) -name $curve -k 0 -k 1;
					} else {
						//Append un punto más
						curve -append -p ($point1.x) ($point1.y) ($point1.z) $curve;	
					}
				}


				string $group[];
				string $cylinder;



				if ($modeAminoacids == "smoothAminoacid"){
					rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 1 -kep 1 -kt 0 -s 0 -d 3 -tol 5.77201e-06 $curve;	//Manteniendo los CVs y las tangentes finales
					$cylinder = ("smoothAminoacidChainTrace_"+$chainLetter);
					polyCylinder -ch on -o on -r 0.1 -h 0.456119 -sa 18 -sc 1 -cuv 3 -name $cylinder;			

				} else if ($modeAminoacids == "regularAminoacid"){
					$cylinder = ("regularAminoacidChainTrace_"+$chainLetter);
					polyCylinder -ch on -o on -r 0.1 -h 0.456119 -sa 18 -sc 1 -cuv 3 -name $cylinder;		
				}	

				/*
				Interfaz: cambiar radio del cilindro
				*/

				rotate -r -os 90 0 0 ;
				select -toggle $cylinder.f[0:35];
				doDelete;
				select -toggle $cylinder;
				select -r $cylinder;	
				move 0 0 0.22806 ($cylinder + ".scalePivot") ($cylinder + ".rotatePivot") ;
				move -rpr 0 0 0 ;
				
				vector $firstCoord = $coordinates[$curvePoints[0]];
				setPosition($cylinder, $firstCoord);	// $uno = primera coordenada


				int $nPoints = size($curvePoints);
				//print("\nnúmero de puntos de la curva: "+$nPoints);
				extrudeRibbon($curve, $cylinder, $nPoints);
				

				string $shaderName = "chainTrace_Shader";
				float $color[] = {239,153,118};

				//assignExistingShader("O_Shader", $cylinder);
				assignShader($shaderName, $color, $cylinder);

				clear($curvePoints);	//Para rellenarlo con los puntos de la siguiente curva

				//Adición a la jerarquía
				parent $curve "Curves";
				parent $cylinder "Backbones";







			} else {

												/********** Modo ADN **********/

				string $chainLetter = $chains[$a];


				if ($modeDNA == "roundedDNA"){
					$curve = ("roundedDNAChainTraceCurve_"+$chainLetter);
					//print("Rounded DNA Chain Trace: "+$chainLetter+"\n");
					$dnaChainTraceCurrentShape = "rounded";
				} else if ($modeDNA == "edgedDNA"){
					$curve = ("edgedDNAChainTraceCurve_"+$chainLetter);
					//print("Edged DNA Chain Trace: "+$chainLetter+"\n");
					$dnaChainTraceCurrentShape = "edged";
				} else if ($modeDNA == "flatDNA"){
					$curve = ("flatDNAChainTraceCurve_"+$chainLetter);
					//print("Flat DNA Chain Trace: "+$chainLetter+"\n");
					$dnaChainTraceCurrentShape = "flat";
				}


				int $nPoints;

				if ($currentStrand == 1){
					if (size($dnaStrand1) > 0){
						for ($p=1; $p<size($dnaStrand1); $p++){	
							int $cp1 = $dnaStrand1[$p-1];
							int $cp2 = $dnaStrand1[$p];
							vector $point0 = $coordinates[$cp1];
							vector $point1 = $coordinates[$cp2];


							if ($p==1){
								curve -d 1 -p ($point0.x) ($point0.y) ($point0.z) -p ($point1.x) ($point1.y) ($point1.z) -name $curve -k 0 -k 1;
							} else {
								curve -append -p ($point1.x) ($point1.y) ($point1.z) $curve;	
							}
						}

						
						//print("curve 1 \n");
						// print($curve);

						$firstCoord = $coordinates[$dnaStrand1[0]];	//Coordenada para el posicionamiento pre-extrusión

						//Cálculo del twist de la hélice, dependiendo del número de bases
						//Cálculo del número de las bases de nucleótidos
						$dnaBases = size($dnaStrand1);
						print("\nNúmero de bases de ADN (G, C, A, T): "+$dnaBases+"\n");
						$nPoints = size($dnaStrand1);
					} 
				} else if ($currentStrand == 2){
					if (size($dnaStrand2) > 0){
						for ($p=1; $p<size($dnaStrand2); $p++){	
							int $cp1 = $dnaStrand2[$p-1];
							int $cp2 = $dnaStrand2[$p];
							vector $point0 = $coordinates[$cp1];
							vector $point1 = $coordinates[$cp2];


							if ($p==1){
								curve -d 1 -p ($point0.x) ($point0.y) ($point0.z) -p ($point1.x) ($point1.y) ($point1.z) -name $curve -k 0 -k 1;
							} else {
								curve -append -p ($point1.x) ($point1.y) ($point1.z) $curve;	
							}
						}

						//print("curve 2 \n");
						//print($curve);

						$firstCoord = $coordinates[$dnaStrand2[0]];




						//Habiendo obtenido $dnaStrand2 por primera vez, procedemos a invertir el sentido de sus átomos en una nueva cadena
						int $aux[];
						for ($i=(size($dnaStrand2)-1); $i>=0; $i--){
							$aux[size($aux)] = $dnaStrand2[$i];
						}
						$dnaStrand2 = $aux;

						$nPoints = size($dnaStrand2);
					}
				}


				


															//Dibujado de la héliz

				string $cylinder;		

				if ($modeDNA == "roundedDNA"){

					rebuildCurve -ch 0 -rpo 1 -rt 0 -end 0 -kr 1 -kcp 1 -kep 0 -kt 0 -s 0 -d 3 -tol 5.77201e-06 $curve;	

					$cylinder = ("roundedDNAChainTrace_"+$chainLetter);
					//polyPlane -ch on -o on -w 2 -h 2 -sw 1 -sh 1 -cuv 2 -name $cylinder;
					polyCylinder -ch on -o on -r 0.3 -h 0.456119 -sa 18 -sc 1 -cuv 3 -name $cylinder;			
					//polyCylinder -ch on -o on -r 0.6 -h 0.456119 -sa 18 -sc 1 -cuv 3 -name $cylinder;			
				} else if ($modeDNA == "flatDNA"){
					rebuildCurve -ch 0 -rpo 1 -rt 0 -end 0 -kr 1 -kcp 1 -kep 0 -kt 0 -s 0 -d 3 -tol 5.77201e-06 $curve;	
					$cylinder = ("flatDNAChainTrace_"+$chainLetter);
					polyPlane -ch on -o on -w 0.005 -h 0.8 -sw 1 -sh 1 -cuv 2 -name $cylinder;
				} else if ($modeDNA == "edgedDNA"){
					rebuildCurve -ch 0 -rpo 1 -rt 0 -end 0 -kr 1 -kcp 1 -kep 0 -kt 0 -s 0 -d 3 -tol 5.77201e-06 $curve;	
					$cylinder = ("edgedDNAChainTrace_"+$chainLetter);
					//polyPlane -ch on -o on -w 0.4 -h 2 -sw 1 -sh 1 -cuv 2 -name $cylinder;
					polyPlane -ch on -o on -w 1.2 -h 2 -sw 1 -sh 1 -cuv 2 -name $cylinder;
					//polyPlane -ch on -o on -w 0.8 -h 2 -sw 1 -sh 1 -cuv 2 -name $cylinder;
				}





				rotate -r -os 90 0 0 ;
				select -toggle $cylinder.f[0:35];
				doDelete;
				select -toggle $cylinder;
				select -r $cylinder;	
				move 0 0 0.22806 ($cylinder + ".scalePivot") ($cylinder + ".rotatePivot") ;
				move -rpr 0 0 0 ;
				


				//$firstCoord es distinta para cada Strand
				setPosition($cylinder, $firstCoord);	
				//print("n points: "+$nPoints+"\n");
				extrudeRibbon($curve, $cylinder, $nPoints);



				if ($modeDNA == "roundedDNA"){
					polySoftEdge -a 360 -ch 1 -name $cylinder;
				}
				


				string $shaderName = "chainTrace_Shader";
				float $color[] = {239,153,118};

				//assignExistingShader("O_Shader", $cylinder);
				assignShader($shaderName, $color, $cylinder);



				//Adición a la jerarquía
				parent $curve "Curves";
				parent $cylinder "Backbones";
			}
		}//fin del dibujado de la línea
	}//fin for




	if (size($dnaStrand1) == 0){
		$sceneDnaStrands = 0;
	} else if (size($dnaStrand1) > 0 && size($dnaStrand2) > 0){
		$sceneDnaStrands = 2;
	} else {
		$sceneDnaStrands = 1;
	}



// print("dna strand 1:\n ");
// print($dnaStrand1);
// print("dna strand 2: \n");
// print($dnaStrand2);

}//fin drawChainTrace







/********** drawHelixes()**********/
//Date of start: 11 July
//Date of finish: 14 July

//Buscando los puntos de CA que forman las hélices, las cuales vienen especificadas en el PDB
//Extruyendo un rectángulo
//Dándole un color 
//Terminándola en un triángulo

global proc drawHelixes(string $mode){	
	//mode = edged, rounded, flat

	global int $numberOfHelixes;
	global int $helixClass[]; 					
	global int $helixLength[];	
	global int $helixInitResNumbers[];
	global int $helixEndResNumbers[];
	global string $chains[];
	global string $helixCurrentShape;	// $helixCurrentShape: rounded, flat, edged


	global string $atomNames[];
	global vector $coordinates[];
	global int $residueNumbers[];

	int $curvePoints[];			//Vector de índices de puntos de la curva
	string $curve;


	if ($numberOfHelixes > 0){
		int $h = 0;	//Para recorrer las hélices



		for ($a=2; $a<size($atomNames); $a++){
			//print($a+"\n");
			if ( ($residueNumbers[$a] >= $helixInitResNumbers[$h]) && ($residueNumbers[$a] < $helixEndResNumbers[$h]) && ($atomNames[$a] == "CA") ){
				//Añadir puntos
				$curvePoints[size($curvePoints)] = $a;

			} else if (($residueNumbers[$a] == $helixEndResNumbers[$h]) && ($atomNames[$a] == "CA")){
				//Estamos en el último punto de la hélice
				//Añadir el último punto de la hélice
				$curvePoints[size($curvePoints)] = $a;

				string $curve = ("helixCurve"+($h+1));	//Empieza siempre por helix1, pero internamente la primera hélice es 0
				//print("Helix "+($h+1)+"\n");
				//print("Helix: "+$curve+"\n");
				//print($curvePoints);


				//Dibujado
				if (size($curvePoints) > 0){
					vector $midPoint;

					for ($p=1; $p<size($curvePoints); $p++){
						int $cp1 = $curvePoints[$p-1];
						int $cp2 = $curvePoints[$p];
						vector $point0 = $coordinates[$cp1];
						vector $point1 = $coordinates[$cp2];

						if ($p==1){
							//Se crea la curva
							//$midPoint = << ($point0.x+$point1.x)/2, ($point0.y+$point1.y)/2, ($point0.z+$point1.z)/2 >>;
							//Curva: midPoint, point1
							curve -d 1 -p ($point0.x) ($point0.y) ($point0.z) -p ($point1.x) ($point1.y) ($point1.z)  -name $curve ;
						} else {
							//Append un punto más
							curve -append -p ($point1.x) ($point1.y) ($point1.z) $curve;	
						}
					}



					//A partir del primer CA, coger el anterior
					//A partir del último CA, coger el siguiente

					//Append

					if ($helixLength[$h] > 3){
						rebuildCurve -ch 0 -rpo 1 -rt 0 -end 0 -kr 1 -kcp 1 -kep 0 -kt 0 -s 0 -d 3 -tol 5.77201e-06 $curve;	
						//Manteniendo los CVs y las tangentes finales
					} else {
						rebuildCurve -ch 0 -rpo 1 -rt 0 -end 0 -kr 1 -kcp 0 -kep 0 -kt 0 -s 0 -d 3 -tol 5.77201e-06 $curve;	
						//No mantener los CVs
					}



					string $group[];
					string $ribbon;
					string $chain;	//Para colorear la hélice por cadena

					$chain = $chains[$curvePoints[1]];
					//print("cadena hélice: "+$chain+"\n");


					if ($mode == "edged"){
						$ribbon = ("edgedHelix_"+($h+1)+"_"+$chain+"_");
						polyPlane -ch on -o on -w 0.8 -h 2 -sw 1 -sh 1 -cuv 2 -name $ribbon;
						/*INTERFAZ:
						Diferentes gruesos: 
							-w 0.05, 0.2
						Diferentes anchos:
							-h 0.8, 1.5
						*/
						$helixCurrentShape = "edged";
					} else if ($mode == "rounded"){
						$ribbon = ("roundedHelix_"+($h+1)+"_"+$chain+"_");
						polyPlane -ch on -o on -w 0.62 -h 2 -sw 1 -sh 1 -cuv 2 -name $ribbon;
						$helixCurrentShape = "rounded";
					} else if ($mode == "flat"){
						$ribbon = ("flatHelix_"+($h+1)+"_"+$chain+"_");
						polyPlane -ch on -o on -w 0.005 -h 0.8 -sw 1 -sh 1 -cuv 2 -name $ribbon;
						$helixCurrentShape = "flat";
					} 
					




					select -toggle $ribbon;
					select -r $ribbon;	
					move 0 0 0.22806 ($ribbon + ".scalePivot") ($ribbon + ".rotatePivot") ;
					move -rpr 0 0 0 ;
					
					vector $firstCoord = $coordinates[$curvePoints[0]];
					setPosition($ribbon, $firstCoord);	

					int $nPoints = size($curvePoints);
					extrudeRibbon($curve, $ribbon, $nPoints);

					//Se suaviza después de dibujarla, en el caso de ser rounded
					if ($mode == "rounded"){
						polySoftEdge -a 360 -ch 1 -name $ribbon;
					}




					//Ordenación en la jerarquía de la molécula
					parent $curve "Curves";
					parent $ribbon "Helixes";




					//Coloreado de la hélice. Tres posibilidades:

					assignColorToHelixByType($helixClass[$h], $ribbon);
					//assignColorToHelixByNumber($h, $ribbon);
					//assignColorToHelixByChain($chain, $ribbon);

				}//fin dibujado hélices


				$h++;	//Siguiente hélice
				clear($curvePoints);

			}//fin del dibujado de una hélice
			//print("dibujado hélice, átomo: "+$a+"\n");
		}//fin for

	} else {
		print ("No existen hélices en la molécula.\n");
	}

}








/********** drawSheets()**********/
//Date of start: 21 July
//Date of finish: 22 July
//fin drawSheets

global proc drawSheets(string $mode){
	global string $atomNames[];
	global vector $coordinates[];
	global int $residueNumbers[];
	global string $chains[];


	global int $numberOfSheets;
	global int $numberOfStrands;

	global string $strandIds[];
	global int $sizes[];
	global int $residueLength[];
	global string $firstRes[];
	global string $firstChain[];
	global int $firstResNumber[];

	global string $lastRes[];
	global string $lastChain[];
	global int $lastResNumber[];

	global int $senses[];

	global string $sheetCurrentShape;



	int $curvePoints[];			//Vector de índices de puntos de la curva

	int $sheetCounter = 0;

	string $sphereName;


	if ($numberOfSheets > 0){
		for ($s=0; $s < size($firstResNumber); $s++){
			// 0 = strand nº1
			//principio: $firstResNumber
			//fin: $lastResNumber
			//for desde inicio hasta fin
			int $firstRes = $firstResNumber[$s];
			int $lastRes = $lastResNumber[$s];

			
			//Buscamos las posiciones de $firstRes y $lastRes
			int $firstAtom = intArrayFind($firstRes, 0, $residueNumbers);

			while ($chains[$firstAtom] != $firstChain[$s]){
				$firstAtom = intArrayFind($firstRes, $firstAtom+1, $residueNumbers);
			} 

			int $lastAtom = intArrayFind($lastRes, $firstAtom, $residueNumbers) + 2;

			//print($firstAtom+" y "+$lastAtom+" en "+$s+"\n");

			$residueLength[$s] = 0;


			//Para calcular el twist de la strand
			//Ahora para cada intervalo [$firstAtom - $lastAtom], buscamos los puntos N y/o C 
			for ($a=$firstAtom; $a<=$lastAtom; $a++){
				if ($a == $firstAtom && $atomNames[$a] == "N"){
					//Sólo se añade la primera N
					$curvePoints[size($curvePoints)] = $a;
				} else if ($atomNames[$a] == "CA"){
					$curvePoints[size($curvePoints)] = $a;
					$residueLength[$s] = $residueLength[$s] +1;
				}
			}

			//print("Strand "+($s+1)+" length: "+$residueLength[$s]+"\n");


			string $chain = $chains[$curvePoints[1]];

			string $curve = ("strandCurve_"+($s+1)+"_from_Strand_"+$strandIds[$s]);

			//Dibujado de la strand
			for ($p=1; $p<size($curvePoints); $p++){
				int $cp1 = $curvePoints[$p-1];
				int $cp2 = $curvePoints[$p];
				vector $point0 = $coordinates[$cp1];
				vector $point1 = $coordinates[$cp2];




				if ($p==1){
					//Se crea la curva
					curve -d 1 -p ($point0.x) ($point0.y) ($point0.z) -p ($point1.x) ($point1.y) ($point1.z)  -name $curve ;


					/* Indicar el sentido creando una esfera */
							float $x = ($point1.x);
							float $y = ($point1.y);
							float $z = ($point1.z);
							$sphereName = ("sense"+($s+1)+"_"+$chain);
							$senseNodeName = `sphere -radius 0.7 -name $sphereName `;		
							move -ws $x $y $z $senseNodeName[0];	

				} else {
					//Append un punto más
					curve -append -p ($point1.x) ($point1.y) ($point1.z) $curve;	
				}	
			}


			if (size($curvePoints) > 3){
				rebuildCurve -ch 0 -rpo 1 -rt 0 -end 0 -kr 1 -kcp 1 -kep 0 -kt 0 -s 0 -d 3 -tol 5.77201e-06 $curve;	
				//Manteniendo los CVs y las tangentes finales
			} else {
				rebuildCurve -ch 0 -rpo 1 -rt 0 -end 0 -kr 1 -kcp 0 -kep 0 -kt 0 -s 0 -d 3 -tol 5.77201e-06 $curve;	
				//No mantener los CVs
			}
			

			//Ponemos smooth la curva
			//rebuildCurve -ch 0 -rpo 1 -rt 0 -end 0 -kr 1 -kcp 1 -kep 0 -kt 0 -s 0 -d 3 -tol 5.77201e-06 $curve;	


			string $group[];
			string $strand;
			int $twist;	//Depende del número de residuos pertenecientes a la strand


			if ($mode == "edged"){
				$strand = ("edgedSheet_"+($s+1)+"_from_Strand_"+$strandIds[$s]+"_"+$chain);
				polyPlane -ch on -o on -w 0.6 -h 2 -sw 1 -sh 1 -cuv 2 -name $strand;
				$sheetCurrentShape = "edged";
			} else if ($mode == "rounded"){
				$strand = ("roundedSheet_"+($s+1)+"_from_Strand_"+$strandIds[$s]+"_"+$chain);
				polyPlane -ch on -o on -w 0.6 -h 2 -sw 1 -sh 1 -cuv 2 -name $strand;
				$sheetCurrentShape = "rounded";
			} else if ($mode == "flat"){
				$strand = ("flatSheet_"+($s+1)+"_from_Strand_"+$strandIds[$s]+"_"+$chain);
				polyPlane -ch on -o on -w 0.005 -h 0.8 -sw 1 -sh 1 -cuv 2 -name $strand;
				$sheetCurrentShape = "flat";
			} 




			select -toggle $strand;
			select -r $strand;	
			move 0 0 0.22806 ($strand  + ".scalePivot") ($strand  + ".rotatePivot") ;
			move -rpr 0 0 0 ;
			
			vector $firstCoord = $coordinates[$curvePoints[0]];
			setPositionStrand($strand, $firstCoord);	



			//Extrusión de la cinta
			int $twist;
			if ($residueLength[$s] < 4){
				$twist = 0;
			} else if ($residueLength[$s] >= 4 && $residueLength[$s] < 6){
				$twist = 90; 
			} else if ($residueLength[$s] >= 6 && $residueLength[$s] < 10){
				$twist = 180;
			} else {
				$twist = 360;
			}

			extrudeStrand($curve, $strand, $twist);




			//Se suaviza después de dibujarla, en el caso de ser rounded
			if ($mode == "rounded"){
				polySoftEdge -a 360 -ch 1 -name $strand ;
			}

			
			if ($s > 0 && $strandIds[$s] != $strandIds[$s-1]){
				$sheetCounter++;
			}



			//Organización de la jerarquía
			parent $curve "Curves";
			parent $strand "Sheets";
			parent $sphereName "Senses";



			int $p = $s+1;
			string $senseSphere[] = `ls ("sense"+$p+"_*")`;
			assignColorToStrandByNumber($s+1, $sheetCounter+1, $strand);					//Strand
			assignColorToStrandByNumber($s+1, $sheetCounter+1, $senseSphere[0]);			//Esfera que indica el sentido de la strand

			//print($sheetCounter+"\n");




			clear $curvePoints;
		}

	} else {
		//print("No hay sheets en la molécula.\n");
	}
}





/********** drawSlabs(string $mode) **********/
/*
Description: En el caso de que haya cadenas de DNA, se dibujan sus bases nitrogenadas con forma de cilindro 
Date: Creation and finish: 16 July 
drawChainTrace debe ir antes que drawSlabs, por el $sceneDnaStrands

mode : { 1, 0 }

*/
global proc drawSlabs(int $mode){
	global string $atomNames[];
	global string $recordTypes[];
	global string $sceneNucleotides[];
	global string $residueNames[];
	global int $dnaStrand1[], $dnaStrand2[];
	global int $sceneDnaStrands;
	global int $slabsConnected;
	global int $numberOfSlabs;

	int $curvePoints[];
	int $connectTwoStrands;	//Variable de seguridad

	//Comprobación de si hay dos strands de ADN, para evitar errores del usuario (como ponerlo en modo 1 "conexión" cuando
	//sólo hay una strand).

	if ($mode == 1){
		if ($sceneDnaStrands == 2){
			$connectTwoStrands = 1;
		} else {
			$connectTwoStrands = 0;
			//print ("No hay dos strands de ADN para conectar.\n");
		}
	} else if ($mode == 0){
		$connectTwoStrands = 0;
	}





	if ($sceneDnaStrands > 0){
		//C5'-N4

		$numberOfSlabs = 0;

		if ($connectTwoStrands == 0){
			//Se calculan los extremos finales, distintos para cada base
			for ($a=1; $a<size($atomNames); $a++){	
				if ($atomNames[$a] == "C4'"){
					//inicio común para todos
					$curvePoints[size($curvePoints)] = $a;
				} else {
					if ($residueNames[$a] == "DC"){
						if (($atomNames[$a] == "N4")){
							$curvePoints[size($curvePoints)] = $a;
							//print($a+"\n");
						}
					} else if ($residueNames[$a] == "DA"){
						if (($atomNames[$a] == "N6")){
							$curvePoints[size($curvePoints)] = $a;
						}
					} else if ($residueNames[$a] == "DG"){
						if (($atomNames[$a] == "N2")){
							$curvePoints[size($curvePoints)] = $a;
						}
					} else if ($residueNames[$a] == "DT"){
						if (($atomNames[$a] == "O4")){
							$curvePoints[size($curvePoints)] = $a;
						}
					}	
				}
			}//fin for


			//Todos los puntos ya están guardados
			//Nos disponemos a dibujarlos

			for ($p=0; $p<size($curvePoints); $p=$p+2){
				//print($curvePoints[$p]+"-"+$curvePoints[($p+1)]+"\n");
				drawConnectedBases($curvePoints[$p], $curvePoints[$p+1], $p, "slabs");
				//drawBond($p, $p+1);
			}


			$slabsConnected = 0;



		} else if ($connectTwoStrands == 1){
			//C-G, A, T
			for ($p=0; $p<size($dnaStrand1); $p++){
				drawConnectedBases($dnaStrand1[$p], $dnaStrand2[$p], $p, "slabs");
				$slabsConnected = 1;
			}
		}




		if ($sceneDnaStrands == 1){
			//Refinamiento de UNA hélice
			string $bases[] = `ls -transforms "*slab*"`;	//	ESTOS BASE_BONDS SON LOS ENLACES BALL AND STICK NORMALES!!!!!!!!!!!!!!!!11111111111


			for ($i=0; $i<size($bases); $i++){
				string $polygon = $bases[$i];

				select -add ($polygon+".f[0:17]") ;	//Tapadera
				select -add ($polygon+".f[55]") ;
				select -add ($polygon+".f[75]") ;
				select -add ($polygon+".f[95]") ;
				select -add ($polygon+".f[115]") ;
				select -add ($polygon+".f[135]") ;
				select -add ($polygon+".f[155]") ;
				select -add ($polygon+".f[175]") ;
				select -add ($polygon+".f[195]") ;
				select -add ($polygon+".f[215]") ;
				select -add ($polygon+".f[235]") ;
				select -add ($polygon+".f[255]") ;
				select -add ($polygon+".f[275]") ;
				select -add ($polygon+".f[295]") ;
				select -add ($polygon+".f[315]") ;
				select -add ($polygon+".f[335]") ;
				select -add ($polygon+".f[355]") ;
				select -add ($polygon+".f[375]") ;
				select -add ($polygon+".f[395]") ;

				delete;

				polyCloseBorder -ch 0 $polygon;


			}
		} else if ($sceneDnaStrands == 2){
			//Refinamiento de DOS hélices
			string $bases[] = `ls -transforms "*slab*"`;


			for ($i=0; $i<size($bases); $i++){
				string $polygon = $bases[$i];

				select -add ($polygon+".f[18:35]") ;	//Tapadera
				select -add ($polygon+".f[36]") ;
				select -add ($polygon+".f[56]") ;
				select -add ($polygon+".f[76]") ;				
				select -add ($polygon+".f[96]") ;
				select -add ($polygon+".f[116]") ;
				select -add ($polygon+".f[136]") ;
				select -add ($polygon+".f[156]") ;
				select -add ($polygon+".f[176]") ;
				select -add ($polygon+".f[196]") ;
				select -add ($polygon+".f[216]") ;
				select -add ($polygon+".f[236]") ;
				select -add ($polygon+".f[256]") ;
				select -add ($polygon+".f[276]") ;
				select -add ($polygon+".f[296]") ;
				select -add ($polygon+".f[316]") ;
				select -add ($polygon+".f[336]") ;
				select -add ($polygon+".f[356]") ;
				select -add ($polygon+".f[376]") ;	

				delete;							
			}
		}
	} else {
		//print("No hay nucleótidos en la molécula.\n");
	}
}







/********** drawStick() **********/
/*
Description: Ball & Stick, con átomos y esferas con el mismo radio.
Radio predeterminado: 0.2
Date: Creation: 29 July
*/
global proc drawStick(float $rad){
	global int $dnaBases;
	global int $isBallAndStickFull;
	global float $stickRadius;

	float $currentRad;


	//Modifica la variable global
	if ($rad > 0.01){	//si no lo pongo en modo stick, modifica la variable global $stickRadius
		$stickRadius = $rad;
		$currentRad = $stickRadius;
	} else {
		$currentRad = $rad;
	}

	float $atomRad = $currentRad; 
	float $bondRad = $currentRad;

	showWaters(0);

	if ($isBallAndStickFull == 0){
		drawBallAndStick("atom");
	}


	string $atoms[] = `listRelatives -c -fullPath  "Molecule|Chain*|Residue*|*Element*|*"`;		//ATOM + HETATM
	string $bonds[] = ` ls "polyCylinder*bond*" `;

	//print("Tamaño del vector bonds: "+size($bonds)+"\n");

	for ($j=0; $j<size($bonds); $j++){
		//if name es distinto del del chain trace o las bases,
		//print(".radius, "+$bondRad+"\n");
	    setAttr ($bonds[$j]+".radius") $currentRad;
	    //print($j+"\n");
	}

	for ($i=0; $i<size($atoms); $i++){
		sphere -edit -radius $currentRad $atoms[$i];
		//print("átomos\n");
	}
}






/********** drawWire() **********/
/*
Description: Ball & Stick, con átomos y esferas con el mismo radio = 0.01.
Date: Creation: 29 July
*/
global proc drawWire(){
	drawStick(0.01);
}





/********** drawCarcass() **********/
/*
	drawCPKStick() v 1.0:
Description v1: Llama a las funciones drawCPK y drawBallAndStick, asignando un nuevo y único shader a los átomos CPK,
con cierta transparencia y un sólo color, mientras que los del modo Ball & Stick mantienen sus shaders iniciales.
Date: Creation: 30 July


	drawCarcass() v 2.0:
Description v2: Sólo dibuja la carcasa, teniendo en cuenta que los átomos presentes en el moleculeMode están dibujados
enteramente. Si no lo estuvieran, primero los completa (drawBallAndStick("atom")), después los duplica para posteriormente
escalarlos hasta tamaño CPK, y así obtener la carcasa a la que se le asignará un cierto color y transparencia.
Date: Modification: 22 August.

Notas: 
	-Si las aguas están escondidas, las nuevas dibujadas de la carcasa también lo estarán.
	-Si se quieren esconder partes de la molécula, también se quedan escondidas las correspondientes de la carcasa (por los nombres de los path).
*/
global proc drawCarcass(){
	global string $elements[];	
	global int $ballAndStickOrCPK;
	global int $isBallAndStickFull;
	global string $moleculeMode;


	global int $isThereCarcass;


	string $shaderName = "transparent_Shader";
	float $color[] = {90,160,80};




	if ($isThereCarcass == 0){

		//Comienza el dibujado de la carcasa
		duplicate -name "Carcass" -upstreamNodes "Molecule";	//Se duplican los átomos. -rc: rename children
																//C_Element_A_002_HYP1 ;


		string $group[] = ` listRelatives -c -fullPath "Carcass|Chain*|Residue*|*Element*|*" `;	
		rescaleAtoms($group, "cpk");	//El tamaño de los átomos es el mismo que CPK

		//Así, independientemente del modo en que estén los átomos en la escena, el escalado se hará para que
		//la carcasa tenga tamaño CPK.


		//Asignación de shader, color y transparencia
		for ($i=0; $i<size($group); $i++){
			assignShader($shaderName, $color, $group[$i]);
			setAttr ($shaderName+".transparency") -type double3 0.85 0.85 0.85;
		}


		showHidden "Carcass|*|*|*|*";	//si los átomos normales estaban escondidos, los de la carcasa también lo estarán



		$isThereCarcass = 1;


	} else {
		//Hay carcasa, y por lo tanto, la muestra
		//showHidden "Carcass";
		showCarcass(1);
	}
}


/* Darle un color nuevo a la carcasa: */








/********** drawScene() **********/
/*
Resumen: Dibuja la molécula de manera predeterminada en la escena, destacando las características relevantes de la molécula.
Descripción: Dibuja los átomos no estándar (HETATM), sus enlaces, las hélices, las sheets y la backbone. 
Los átomos estándar quedan dibujados pero se mantienen escondidos, ya que su información la dan más condensada hélices, sheets y backbone.
Date: Creation, finish: 4 August 2015.
*/
global proc drawScene(){
	global string $moleculeMode;	
	global float $cubeColor[];
	global int $isBallAndStickFull;
	global int $isThereCarcass;
	global float $stickRadius;
	global int $isThereDNA;
	global string $colorMode;		// {cpk, monochrome, chain, residue}
	global string $alphabet[];
	global int $keepHelixes;
	global int $keepSheets;
	global int $keepChainTraces;
	global int $keepCarcass;
	global int $numberOfSheets;
	global int $numberOfHelixes;
	global int $regularDrawn;
	global string $modeAminoacids;




	$isBallAndStickFull = 0;		
	$isThereCarcass = 0;
	$stickRadius = 0.2;
	$keepHelixes = 0;
	$keepSheets = 0;
	$keepChainTraces = 0;
	$keepCarcass = 0;
	$keepSlabs = 1;
	$regularDrawn = 0;	//chain trace regular
	$colorMode = "cpk";
	$modeAminoacids = "smoothAminoacid";

	if ($isThereDNA == 1) $keepChainTraces = 1;



	//Ocultar grid aquí?
	//grid -toggle 0;
	


	modelEditor -e -lights false modelPanel4;
	modelEditor -e -cameras false modelPanel4;
	modelEditor -e -nurbsCurves false modelPanel4;
	modelEditor -e -cv false modelPanel4;
	modelEditor -e -hud false modelPanel4;


	drawAtoms();						//Dibuja TODOS los átomos, tanto ATOM como HETATM

	drawBallAndStick("hetatm");

	showWaters(0);						//OFF en Ball&Stick. Se pondrán en ON en CPK.

	drawChainTrace("smoothAminoacid", "roundedDNA");	//roundedDNA por defecto

	drawSlabs(1);						//Si hay dos cadenas de ADN, une sus bases

	drawHelixes("rounded");

	drawSheets("rounded");



	$moleculeMode = "secondary";






	 					/*Ultimar jerarquía*/

	createNode transform -s -n "Scene";
	parent "Molecule" "Scene";
	parent "Bonds" "Scene";
	parent "Backbones" "Scene";
	parent "Curves" "Scene";
	if ($numberOfHelixes > 0) parent "Helixes" "Scene";
	if ($numberOfSheets > 0) {
		parent "Sheets" "Scene";
		parent "Senses" "Scene";
	}



						/* Cámaras */
	setCameras();	


						/* Luces */
	setLights();


	 					/* Environment */
	drawCube();



	//optionVar -intValue ResetModelViewsOnNewScene 1;

						/* Interfaz, Parte 2 */
	interfacePart2();


	print("****************** Fin del dibujado ******************");
}







/********** createCamera() **********/
/*
Aug 6
*/
global proc string[] createCamera(){
	string $cameraName[] = ` camera -centerOfInterest 5 -focalLength 50 -lensSqueezeRatio 1 -cameraScale 1 -horizontalFilmAperture 1.4173 -horizontalFilmOffset 0 -verticalFilmAperture 0.9449 -verticalFilmOffset 0 -filmFit Fill -overscan 1 -motionBlur 0 -shutterAngle 144 -nearClipPlane 0.1 -farClipPlane 10000 -orthographic 0 -orthographicWidth 30 -panZoomEnabled 0 -horizontalPan 0 -verticalPan 0 -zoom 1 `; 
	
	objectMoveCommand; 
	cameraMakeNode 2 "";
	//print ("Cámara creada.\n");

	return $cameraName;
}







/********** setCameras() **********/
/*
Aug 6-Aug 8
*/
global proc setCameras(){
	global string $sceneNonStandardResidues[];
	global int $isThereDNA;

	global float $bbox[];
	global vector $corner1;
	global vector $corner2;
	global vector $midPoint;						//Punto medio de la molécula

	global vector $frontCameraInitPos;
	global vector $backCameraInitPos;
	global vector $rightCameraInitPos;
	global vector $leftCameraInitPos;
	global vector $spinCameraInitPos;
	global vector $topCameraInitPos;

	global string $frontCameraName;
	global string $backCameraName;
	global string $leftCameraName;
	global string $rightCameraName;
	global string $spinCameraName;
	global string $topCameraName;

	global float $animationSpeed;

	global float $sceneWidth;	//Para ajustar el tamaño del plano del suelo
	global float $sceneHeight;



	$animationSpeed = 0.2;

	if ($isThereDNA == 0){
		$bbox = exactWorldBoundingBox ("Scene");	
	} else {
		$bbox = exactWorldBoundingBox ("*ChainTrace*");	
	}

	$corner1 = << $bbox[0], $bbox[1], $bbox[2]>>; 	//left
	$corner2 = << $bbox[3], $bbox[4], $bbox[5]>>; 	//right

	vector $p1 = << $bbox[0], $bbox[4], $bbox[2] >> ;
	vector $p2 = << $bbox[0], $bbox[4], $bbox[5] >> ;
	vector $p3 = << $bbox[0], $bbox[1], $bbox[5] >> ;
	vector $p4 = << $bbox[3], $bbox[1], $bbox[2] >> ;



	vector $m1 = calculateMidPoint($corner1, $p2);	//LEFT CAMERA
	vector $m2 = calculateMidPoint($corner2, $p4);	//RIGHT CAMERA
	vector $m3 = calculateMidPoint($corner2, $p3);	//FRONT CAMERA
	vector $m4 = << $m3.x, $m3.y, $m1.z >> ;		//BACK CAMERA
	vector $m5 = calculateMidPoint($corner2, $p1); 	//TOP CAMERA




	calculateSceneMidPoint();


	//Scene height: distancia entre p2 y p3
	float $x1 = $p2.x;
	float $x2 = $p3.x;
	float $y1 = $p2.y;
	float $y2 = $p3.y;
	float $z1 = $p2.z;
	float $z2 = $p3.z;

	$sceneHeight = sqrt( `pow ($x2 - $x1) 2` + `pow ($y2 - $y1) 2` + `pow ($z2 - $z1) 2` );
	//print("\nScene height: "+$sceneHeight);





	//Scene width: distancia entre p2 y corner2
	float $x1 = $p2.x;
	float $x2 = $corner2.x;
	float $y1 = $p2.y;
	float $y2 = $corner2.y;
	float $z1 = $p2.z;
	float $z2 = $corner2.z;

	$sceneWidth = sqrt( `pow ($x2 - $x1) 2` + `pow ($y2 - $y1) 2` + `pow ($z2 - $z1) 2` );
	//print("\nScene width: "+$sceneWidth);




	//Posiciones de las cámaras
	// if ($sceneHeight > ($sceneWidth*1.2)){
	// 	$frontCameraInitPos = 	<< $m3.x, $m3.y, $m3.z + 140 >>;
	// 	$backCameraInitPos = 	<< $m4.x, $m4.y, $m4.z - 140 >>;
	//} else {
	$frontCameraInitPos = 	<< $m3.x, $m3.y, $m3.z + 150 >>;
	$backCameraInitPos = 	<< $m4.x, $m4.y, $m4.z - 150 >>;
	//}


	$leftCameraInitPos = 	<< $m1.x - 150, $m1.y, $m1.z >>;	//Previamente a 120
	$rightCameraInitPos = 	<< $m2.x + 150, $m2.y, $m2.z >>;
	$topCameraInitPos = 	<< $m5.x, $corner2.y + 170, $m5.z >>;		//Top_Camera tiene mucha más altura que, en comparación, Front_Camera de su objetivo.
																	//La función de Front y Back Cameras es de ofrecer un primer plano.
	$spinCameraInitPos = 	$frontCameraInitPos;





	//if $sceneHeight > ($sceneWidth*2), hay que echar mucho más atrás las cámaras frontales y laterales






					// Cámara frontal: PREDETERMINADA

	string $fCameraName[] = createCamera();
	string $fCameraShape = $fCameraName[1];


	$frontCameraName = "Front_Camera";
	rename $fCameraName[0] $frontCameraName;
	rename ($fCameraName[0]+"_aim") ($frontCameraName+"_aim");
	string $fAim = ($frontCameraName + "_aim");


	//Ajustar a dónde apunta
	setAttr ($fAim + ".translateX") ($midPoint.x);
	setAttr ($fAim + ".translateY") ($midPoint.y);
	setAttr ($fAim + ".translateZ") ($midPoint.z);


	//Trasladar en Z la cámara
	setAttr ($frontCameraName + ".translateX") ($frontCameraInitPos.x);
	setAttr ($frontCameraName + ".translateY") ($frontCameraInitPos.y);
	setAttr ($frontCameraName + ".translateZ") ($frontCameraInitPos.z);			//Más alejado	

	lookThroughModelPanel $frontCameraName modelPanel4;	







					// Cámara trasera

	string $bCameraName[] = createCamera();
	string $bCameraShape = $bCameraName[1];


	$backCameraName = "Back_Camera";
	rename $bCameraName[0] $backCameraName;
	rename ($bCameraName[0]+"_aim") ($backCameraName+"_aim");
	string $bAim = ($backCameraName + "_aim");


	//Ajustar a dónde apunta
	setAttr ($bAim + ".translateX") ($midPoint.x);
	setAttr ($bAim + ".translateY") ($midPoint.y);
	setAttr ($bAim + ".translateZ") ($midPoint.z);


	//Trasladar en -Z la cámara
	setAttr ($backCameraName + ".translateX") ($backCameraInitPos.x);
	setAttr ($backCameraName + ".translateY") ($backCameraInitPos.y);
	setAttr ($backCameraName + ".translateZ") ($backCameraInitPos.z);			//Más alejado

	//lookThroughModelPanel $backCameraName modelPanel4;	







					// Cámara right

	string $rCameraName[] = createCamera();
	string $rCameraShape = $rCameraName[1];


	$rightCameraName = "Right_Camera";
	rename $rCameraName[0] $rightCameraName;
	rename ($rCameraName[0]+"_aim") ($rightCameraName+"_aim");
	string $rAim = ($rightCameraName + "_aim");


	//Ajustar a dónde apunta
	setAttr ($rAim + ".translateX") ($midPoint.x);
	setAttr ($rAim + ".translateY") ($midPoint.y);
	setAttr ($rAim + ".translateZ") ($midPoint.z);


	//Trasladar en +X la cámara
	setAttr ($rightCameraName + ".translateX") ($rightCameraInitPos.x);
	setAttr ($rightCameraName + ".translateY") ($rightCameraInitPos.y);
	setAttr ($rightCameraName + ".translateZ") ($rightCameraInitPos.z);			//Más alejado

	//lookThroughModelPanel $rightCameraName modelPanel4;	








					// Cámara left

	string $lCameraName[] = createCamera();
	string $lCameraShape = $lCameraName[1];


	$leftCameraName = "Left_Camera";
	rename $lCameraName[0] $leftCameraName;
	rename ($lCameraName[0]+"_aim") ($leftCameraName+"_aim");
	string $lAim = ($leftCameraName + "_aim");


	//Ajustar a dónde apunta
	setAttr ($lAim + ".translateX") ($midPoint.x);
	setAttr ($lAim + ".translateY") ($midPoint.y);
	setAttr ($lAim + ".translateZ") ($midPoint.z);


	//Trasladar en -X la cámara
	setAttr ($leftCameraName + ".translateX") ($leftCameraInitPos.x);
	setAttr ($leftCameraName + ".translateY") ($leftCameraInitPos.y);
	setAttr ($leftCameraName + ".translateZ") ($leftCameraInitPos.z);			//Más alejado

	//lookThroughModelPanel $leftCameraName modelPanel4;	







					// Cámara de rotación

	//Curva circular donde girará la cámara
	float $x2 = $spinCameraInitPos.x;
	float $x1 = $midPoint.x;
	float $y2 = $spinCameraInitPos.y;
	float $y1 = $midPoint.y;
	float $z2 = $spinCameraInitPos.z;
	float $z1 = $midPoint.z;
	string $spinCameraCircle = "spinCameraCurve";

	float $radius = sqrt( `pow ($x2 - $x1) 2` + `pow ($y2 - $y1) 2` + `pow ($z2 - $z1) 2` );

	circle -ch on -o on -r $radius -name $spinCameraCircle -nr 0 1 0 -c ($midPoint.x) ($midPoint.y) ($midPoint.z) ;	//-c : center
	parent $spinCameraCircle "Curves";




	string $sCameraName[] = createCamera();		//Posicionada igual que Front_Camera
	string $sCameraShape = $sCameraName[1];

	$spinCameraName = "Spin_Camera";
	rename $sCameraName[0] $spinCameraName;
	rename ($sCameraName[0]+"_aim") ($spinCameraName+"_aim");
	string $sAim = ($spinCameraName + "_aim");


	//Ajustar a dónde apunta
	setAttr ($sAim + ".translateX") ($midPoint.x);
	setAttr ($sAim + ".translateY") ($midPoint.y);
	setAttr ($sAim + ".translateZ") ($midPoint.z);

			//Trasladar en -X la cámara
	setAttr ($spinCameraName + ".translateX") ($spinCameraInitPos.x);
	setAttr ($spinCameraName + ".translateY") ($spinCameraInitPos.y);
	setAttr ($spinCameraName + ".translateZ") ($spinCameraInitPos.z);			//Más alejado

	//lookThroughModelPanel $leftCameraName modelPanel4;





						/*** Convertir el círculo en un motion path para la cámara ***/


	//Bloquear los atributos de traslación del aim de la cámara

	setAttr -l true  "Spin_Camera_aim.translateX";	
	setAttr -l true  "Spin_Camera_aim.translateY";
	setAttr -l true  "Spin_Camera_aim.translateZ";


	//Playback, ponerlo en "continuous"
	cycleCheck -e off;


	//Seleccionar cámara y círculo
	select $spinCameraName $spinCameraCircle;

	playbackOptions -min 1 -max 300 ;
	//Conectarlos 
	pathAnimation -fractionMode true -follow false -startTimeU `playbackOptions -query -minTime` -endTimeU  `playbackOptions -query -maxTime`;


	//Centrar el pivot de la circunferencia, colocándolo en $midPoint
	move -r ($midPoint.x) ($midPoint.y) ($midPoint.z) ($spinCameraCircle + ".scalePivot") ($spinCameraCircle + ".rotatePivot") ;
	setAttr ($spinCameraCircle + ".rotateY") 180;

	//Preparación del playback
	currentTime 1 ;
	playbackOptions -loop continuous -playbackSpeed $animationSpeed;

	







					// Cámaras de HETATM, 10 Aug

	/*
		para cada elemento en $sceneNonStandardResidues
			hago un group[] = `ls "Residue_*_"+$currentName`
				para cada elemento de group
					calcular su Bounding box y su punto central
					coloco una cámara frontal en residueMidPoint
	*/

	for ($i=0; $i<size($sceneNonStandardResidues); $i++){
		string $residue = $sceneNonStandardResidues[$i];		// "MAN"

		if ($residue != "HOH"){
			string $group[] = `ls ("Residue_*_"+$residue)`;		//Todos los grupos de residuos de ese tipo en la jerarquía

			for ($r=0; $r<size($group); $r++){
				//Crear una cámara y posicionarla en el punto medio de su bounding box

				string $cameraName = "Camera_"+$group[$r];	// "Camera_Residue_A_222_GOL"

				float $residueBbox[] = exactWorldBoundingBox($group[$r]);
				vector $corner1 = << $residueBbox[0], $residueBbox[1], $residueBbox[2]>>; 	//left
				vector $corner2 = << $residueBbox[3], $residueBbox[4], $residueBbox[5]>>; 	//right
				vector $residueMidPoint = calculateMidPoint($corner1, $corner2);
				vector $residueCameraInitPos = << $residueMidPoint.x, $residueMidPoint.y, $residueMidPoint.z+20 >>;


				//Crear la cámara apuntando a $residueMidpoint
				string $newCameraName[] = createCamera();
				string $newCameraShape = $newCameraName[1];

				rename $newCameraName[0] $cameraName;
				rename ($newCameraName[0]+"_aim") ($cameraName+"_aim");

				string $newAim = ($cameraName+"_aim");

				//print ($newCameraName[1]+"\n");

				
				//Hacerla que apunte a residuemidpoint
				setAttr ($newAim + ".translateX") ($residueMidPoint.x);
				setAttr ($newAim + ".translateY") ($residueMidPoint.y);
				setAttr ($newAim + ".translateZ") ($residueMidPoint.z);


				//Trasladar la cámara
				setAttr ($cameraName + ".translateX") ($residueCameraInitPos.x);
				setAttr ($cameraName + ".translateY") ($residueCameraInitPos.y);
				setAttr ($cameraName + ".translateZ") ($residueCameraInitPos.z);

			}


			//Se arregla un bug de maya que hace renombrar malamente las shapes de las cámaras que terminan en un número:
			//Cam_Residue_A_154_SO4 -> Cam_Residue_A_154_SOShape4


		}
	}


	string $selected[] = `ls -shapes "Camera_Residue_*Shape*"`;
			string $toChange[];
			for ($i=0; $i<size($selected); $i++){
				if (`match "[0-9]$" $selected[$i]` != "" ){
					//hay que cambiarlo
					$toChange[size($toChange)] = $selected[$i];
				}
			}

			//print (size($toChange));

			for ($i=0; $i<size($toChange); $i++){
				string $shape = $toChange[$i];
				//Modificación:
				int $last = strGet($shape, size($shape));
				string $new = `substring $shape 1 (size($shape)-6)`;
				$new = $new + $last + "Shape";
				// print($shape+"\n");
				// print($new+"\n");
				rename $shape $new;
			}









					// Cámara top

	string $tCameraName[] = createCamera();



	string $tCameraShape = $tCameraName[1];


	$topCameraName = "Top_Camera";
	rename $tCameraName[0] $topCameraName;
	rename ($tCameraName[0]+"_aim") ($topCameraName+"_aim");
	string $tAim = ($topCameraName + "_aim");



	//Ajustar a dónde apunta
	setAttr ($tAim + ".translateX") ($midPoint.x);
	setAttr ($tAim + ".translateY") ($midPoint.y);
	setAttr ($tAim + ".translateZ") ($midPoint.z);


	//Trasladar en -X la cámara
	setAttr ($topCameraName + ".translateX") ($topCameraInitPos.x);
	setAttr ($topCameraName + ".translateY") ($topCameraInitPos.y);
	setAttr ($topCameraName + ".translateZ") ($topCameraInitPos.z);			//Más alejado


	//lookThroughModelPanel $topCameraName modelPanel4;









					//Organización final en la jerarquía

	select "camera*_group";
	doGroup 0 1 1;
	rename "Cameras";
	hide "Cameras";		//Para que no se vean las rectas que producen sus aims en la escena



	//lookThroughModelPanel $spinCameraName modelPanel4;

}





/********** activateCamera() **********/
/*
Aug 29
*/
global proc activateCamera(string $name){
	//Get the actual camera
	string $panel = "modelPanel4";
	string $whichCam = `modelPanel -q -camera $panel`;

	if ($whichCam != $name){
		//Cambiarla por la nueva cámara si no es la actual
		lookThroughModelPanel $name $panel;
	}
}






/********** restoreCurrentCameraPosition() **********/
/*
Aug 7
*/
global proc restoreCurrentCameraPosition(){
	global string $frontCameraName;				
	global string $backCameraName;
	global string $rightCameraName;
	global string $leftCameraName;
	global string $spinCameraName;
	global string $topCameraName;

	global vector $frontCameraInitPos;
	global vector $backCameraInitPos;
	global vector $rightCameraInitPos;
	global vector $leftCameraInitPos;
	global vector $spinCameraInitPos;
	global vector $topCameraInitPos;





	//Current panel
	//string $panel = `getPanel -wf`;
	string $panel = "modelPanel4";

	//Gets la current camera
	string $whichCam = `modelPanel -q -camera $panel`;
	//string $whichCamShape[] = `ls -dag -shapes -ap $whichCam`;


	//La translada hasta su $*CameraInitPos
	string $char = strGet($whichCam, 1);

	if ($char == "F"){
		setAttr ($whichCam + ".translateX") ($frontCameraInitPos.x);
		setAttr ($whichCam + ".translateY") ($frontCameraInitPos.y);
		setAttr ($whichCam + ".translateZ") ($frontCameraInitPos.z);
		//print ("front");
	} else if ($char == "B"){
		setAttr ($whichCam + ".translateX") ($backCameraInitPos.x);
		setAttr ($whichCam + ".translateY") ($backCameraInitPos.y);
		setAttr ($whichCam + ".translateZ") ($backCameraInitPos.z);
		//print ("back");
	} else if ($char == "L"){
		setAttr ($whichCam + ".translateX") ($leftCameraInitPos.x);
		setAttr ($whichCam + ".translateY") ($leftCameraInitPos.y);
		setAttr ($whichCam + ".translateZ") ($leftCameraInitPos.z);
		//print ("left");
	} else if ($char == "R"){
		setAttr ($whichCam + ".translateX") ($rightCameraInitPos.x);
		setAttr ($whichCam + ".translateY") ($rightCameraInitPos.y);
		setAttr ($whichCam + ".translateZ") ($rightCameraInitPos.z);
		//print ("right");
	} else if ($char == "S"){
		//Spin camera
		setAttr ($whichCam + ".translateX") ($spinCameraInitPos.x);
		setAttr ($whichCam + ".translateY") ($spinCameraInitPos.y);
		setAttr ($whichCam + ".translateZ") ($spinCameraInitPos.z);
	} else if ($char == "T"){
		//Top camera
		setAttr ($whichCam + ".translateX") ($topCameraInitPos.x);
		setAttr ($whichCam + ".translateY") ($topCameraInitPos.y);
		setAttr ($whichCam + ".translateZ") ($topCameraInitPos.z);
	}
}







/********** increaseAnimationSpeed() **********/
/*
Aug 12
*/
global proc increaseAnimationSpeed(){
	global float $animationSpeed;

	$animationSpeed = $animationSpeed + 0.1;

	playbackOptions -loop continuous -playbackSpeed $animationSpeed;
}






/********** decreaseAnimationSpeed() **********/
/*
Aug 12
*/
global proc decreaseAnimationSpeed(){
	global float $animationSpeed;

	$animationSpeed = $animationSpeed - 0.1;

	playbackOptions -loop continuous -playbackSpeed $animationSpeed;
}






/********** setLights() **********/
/*
Aug 10
*/
global proc setLights(){
	global float $bbox[];
	global vector $corner1;
	global vector $corner2;
	global vector $midPoint;


	global vector $frontCameraInitPos;
	global vector $backCameraInitPos;
	global vector $rightCameraInitPos;
	global vector $leftCameraInitPos;
	global vector $spinCameraInitPos;
	global vector $topCameraInitPos;

	global string $frontCameraName;
	global string $backCameraName;
	global string $leftCameraName;
	global string $rightCameraName;
	global string $spinCameraName;
	global string $topCameraName;



	global string $keyLightName ;
	global string $fillLightName ;
	global string $backLightName ;

	global vector $keyLightPosition;
	global vector $fillLightPosition;
	global vector $backLightPosition;

	global float $initialKeyIntensity;
	global float $initialFillIntensity;

	global float $initialKeyColor[];
	global float $initialFillColor[];
	global float $initialBackColor[];


	//La perspectiva CPK que sale bien de sombras y profundidad es la Izquierda, porque es donde está Key_light posicionada
	//Fill_Light, con mucha intensidad, saca ruido en la superficie donde da.






	$keyLightName = "Key_Light";
	$fillLightName = "Fill_Light";
	$backLightName = "Back_Light";


	$keyLightPosition = << $leftCameraInitPos.x, $corner2.y+120, $midPoint.z >>;		//Arriba izquierda (150 previously)
	$fillLightPosition = << $rightCameraInitPos.x, $corner1.y+80, $midPoint.z >>;		//Abajo derecha	( 100 previously)
	$backLightPosition = << $midPoint.x, $midPoint.y, $backCameraInitPos.z-100 >>;		//Detrás



	$initialKeyIntensity = 1.2;	//Antes, intensidad 0.7
	$initialFillIntensity = 0.8;
	$initialBackIntensity = 0.5;



	//Crear tres point lights
	pointLight -name $keyLightName -intensity $initialKeyIntensity ;	//Probar 1.25
	pointLight -name $fillLightName -intensity $initialFillIntensity ;
	pointLight -name $backLightName -intensity $initialBackIntensity ;	//Probar 0.25


	//Escalar Back_Light
	setAttr ($backLightName+".scaleX") 200;
	setAttr ($backLightName+".scaleY") 100;
	setAttr ($backLightName+".scaleZ") 50;


	setAttr ($keyLightName+"Shape.useRayTraceShadows") 1;
	setAttr ($fillLightName+"Shape.useRayTraceShadows") 1;	//esta da más o menos igual
	setAttr ($backLightName+"Shape.useRayTraceShadows") 1;


	//Turn on Depth map shadow
	setAttr ($keyLightName+"Shape.useDepthMapShadows") 1;
	setAttr ($fillLightName+"Shape.useDepthMapShadows") 0;
	setAttr ($backLightName+"Shape.useDepthMapShadows") 0;
	//depth map shadows en Key_Light hace que las sombras queden más difuminadas. Sin ellas 


	//Cambiar el color de las sombras, de un negro a un gris más suave, para que no sea ésta tan pronunciada
	setAttr ($keyLightName+"Shape.shadowColor") -type double3 0.744686 0.744686 0.744686 ;
	setAttr ($keyLightName+"Shape.volumeShadowSamples") 2;
	$initialKeyColor = {0.744686, 0.744686, 0.744686 };


	//Trasladar Key_Light a la izquierda y arriba (de Front_Camera)
	setAttr ($keyLightName+".translateX") ($keyLightPosition.x);
	setAttr ($keyLightName+".translateY") ($keyLightPosition.y);
	setAttr ($keyLightName+".translateZ") ($keyLightPosition.z);


	//Trasladar Fill_Light a la derecha y abajo (de Front_Camera)
	//Cambio: Trasladar Fill_Light a la derecha y ENMEDIO (de Front_Camera)
	setAttr ($fillLightName+".translateX") ($fillLightPosition.x);
	setAttr ($fillLightName+".translateY") ($fillLightPosition.y);
	setAttr ($fillLightName+".translateZ") ($fillLightPosition.z);


	//Trasladar Back_Light atrás de Front_Camera
	setAttr ($backLightName+".translateX") ($backLightPosition.x);
	setAttr ($backLightName+".translateY") ($backLightPosition.y);
	setAttr ($backLightName+".translateZ") ($backLightPosition.z);


	setAttr ($keyLightName+"Shape.dmapFilterSize") 3;	


	//Organización de la jerarquía
	select "*_Light";
	doGroup 0 1 1;
	rename "Lights";
}








/********** changeLightsIntensity(string $light, float $value) **********/
/*
Date: Aug 12

changeLightsIntensity ("Key_Light", 1);
changeLightsIntensity ("Fill_Light", 0.2);

*/
global proc changeLightsIntensity(string $light, float $value){
	global string $keyLightName ;
	global string $fillLightName;
	global string $backLightName;

	if ($light == $keyLightName){
		float $keyIntensity = `getAttr ($light + ".intensity")`;
	
		setAttr ($light + ".intensity") ($value);

	} else if ($light == $fillLightName){
		float $fillIntensity = `getAttr ($light + ".intensity")`;
		
		setAttr ($light + ".intensity") ($value);

	} else if ($light == $backLightName){
		float $backIntensity = `getAttr ($light + ".intensity")`;

		setAttr ($light + ".intensity") ($value);
	} 
}









/********** moveLights(int $n) **********/
/*
Date: Aug 11
Description: Aleja o acerca las luces a la molécula, para que el usuario las pueda ajustar
Argumentos: $n, puede ser positivo o negativo. +-10.
*/
global proc moveLights(int $n){
	global vector $keyLightPosition;
	global vector $fillLightPosition;
	global vector $backLightPosition;

	global string $keyLightName, $fillLightName, $backLightName;



	//Se mueven en Y
	float $keyLightY = (`getAttr ($keyLightName + ".translateY")` + $n);
	setAttr ($keyLightName+".translateY") $keyLightY;


	float $fillLightY = (`getAttr ($fillLightName + ".translateY")` + $n);
	setAttr ($fillLightName+".translateY") $fillLightY;


	//Se mueve en Z
	float $backLightZ = (`getAttr ($backLightName + ".translateZ")` + $n);
	setAttr ($backLightName+".translateY") $backLightZ;
}







/********** restoreLight() **********/
/*
Description: Devuelve sus posiciones Y (las únicas que se cambian), y sus intensidades, a las luces Key y Fill
Date: Aug 11-12
*/
global proc restoreLight(string $lightName){
	global string $keyLightName;
	global string $fillLightName;
	global string $backLightName;


	global vector $keyLightPosition;
	global vector $fillLightPosition;
	global vector $backLightPosition;


	global float $initialKeyIntensity;
	global float $initialFillIntensity;
	global float $initialBackIntensity;


	global float $initialKeyColor[];
	global float $initialFillColor[];
	global float $initialBackColor[];



	if ($lightName == $keyLightName){
		setAttr ($keyLightName+".translateY") ($keyLightPosition.y);
		setAttr ($keyLightName+".intensity") ($initialKeyIntensity);
		setAttr ($keyLightName+"Shape.useRayTraceShadows") 1;
		setAttr ($keyLightName+"Shape.shadowColor") -type double3 $initialKeyColor[0] $initialKeyColor[1] $initialKeyColor[2] ;
		setAttr ($keyLightName+"Shape.color") -type double3 1 1 1 ;	//color de la luz: blanco

	} else if ($lightName == $fillLightName){
		setAttr ($fillLightName+".translateY") ($fillLightPosition.y);
		setAttr ($fillLightName+".intensity") ($initialFillIntensity);
		setAttr ($fillLightName+"Shape.useRayTraceShadows") 1;
		setAttr ($fillLightName+"Shape.shadowColor") -type double3 0 0 0;
		setAttr ($fillLightName+"Shape.color") -type double3 1 1 1 ;	

	} else {
		setAttr ($backLightName+".translateY") ($backLightPosition.y);
		setAttr ($backLightName+".intensity") ($initialBackIntensity);
		setAttr ($backLightName+"Shape.useRayTraceShadows") 1;
		setAttr ($backLightName+"Shape.shadowColor") -type double3 0 0 0;
		setAttr ($backLightName+"Shape.color") -type double3 1 1 1 ;	
	}

	deactivateShadows(0);

	showHidden $keyLightName $fillLightName $backLightName;
}






//Para el renderizado
global proc deactivateShadows(int $yn){
	global string $keyLightName, $fillLightName, $backLightName;


	if ($yn == 1){
		//Apagar
		setAttr ($keyLightName+"Shape.useDepthMapShadows") 0;

		setAttr ($keyLightName+"Shape.useRayTraceShadows") 0;
		setAttr ($fillLightName+"Shape.useRayTraceShadows") 0;	
		setAttr ($backLightName+"Shape.useRayTraceShadows") 0;

	} else {
		//Encender
		setAttr ($keyLightName+"Shape.useDepthMapShadows") 1;

		setAttr ($keyLightName+"Shape.useRayTraceShadows") 1;
		setAttr ($fillLightName+"Shape.useRayTraceShadows") 1;	
		setAttr ($backLightName+"Shape.useRayTraceShadows") 1;
	}
}







/********** renderConfig() **********/
/*
Description: Actualiza los parámetros del renderizado, después de que el usuario los haya elegido
Date: Aug 12
			Modes: mentalray, mayasoftware
*/
global proc renderConfig(string $renderer){
	global int $renderWidth;
	global int $renderHeight;
	global int $renderFormat;
	global int $boolEnvironment;
	global int $boolAllShadows;
	global string $renderStyle;	//Realistic, caustics, vector, cartoon
	global string $renderEdgeStyle;
	global string $renderFillStyle;

	// $renderWidth = 1920;
	// $renderHeight = 1080;

	// $renderWidth = 1280;
	// $renderHeight = 720;

	// $renderWidth = 320; 
	// $renderHeight = 240;

	// $renderWidth = 640;
	// $renderHeight = 480;
	// $renderFormat = 32; 	//PNG


	if ($renderer == "mayasoftware"){
		setAttr( "defaultRenderGlobals.currentRenderer" ) -typ "string" "mayaSoftware";
	} else if ($renderer == "mentalray"){
		setAttr( "defaultRenderGlobals.currentRenderer" ) -typ "string" "mentalRay";	
	}


	//Formato de imagen
	setAttr "defaultRenderGlobals.imageFormat" $renderFormat;	//PNG

	//Resolución
	setAttr "defaultResolution.width" $renderWidth;
	setAttr "defaultResolution.height" $renderHeight;


	if ($renderWidth == 320 && $renderHeight == 240){
		setAttr "defaultResolution.deviceAspectRatio" 1.333;	//para 320x240
		setAttr "defaultResolution.pixelAspect" 1.000 ;			//para 320x240	

	} else if ($renderWidth == 720 || $renderWidth == 1920){
		setAttr "defaultResolution.deviceAspectRatio" 1.777;
		setAttr "defaultResolution.pixelAspect" 1.000 ;	
	}
}








/********** renderVector(string $camera, string $fillStyle, string $edgeStyle) **********/
//$fillStyle : "SingleColor", "TwoColor", "FourColor", "FullColor", "AverageColor", "AreaGradient", "MeshGradient", "None"
//$edgeStyle : "Outline", "EntireMesh", "None"
global proc renderVector(string $camera, string $fillStyle, string $edgeStyle){
	//renderVector("Front_Camera", "TwoColor", "Outline");
	//vectorize -imageFormat png -w 1920 -h 1080 -dl 0 -ct 7.5 -scf 0  -fs "SingleColor" -sb -es "EntireMesh" -c "Front_Camera" -cf -rv -ff "name.png"

	global int $renderWidth;
	global int $renderHeight;
	global string $pdbName;


	vectorize -imageFormat "png" -h $renderHeight -w $renderWidth -dl 0 -ff "name_#.ext" -of $pdbName -ct 7.5 -scf 0 -fs $fillStyle -sb -es $edgeStyle -c $camera -cf -rv ;


	//-rf reflections
	//-sb showBackFaces
	//-ro Safe
	//-dl 0 NO CAMBIAR
}







/********** render() **********/
/*
	style: {realistic, cartoon, vector}

	render("realistic");
	render("cartoon");
	render("vector");

	fin: 15 Aug
*/
global proc render(string $renderStyle){
	/* Interactúan con la interfaz: */
	global int $renderWidth;
	global int $renderHeight;
	global int $renderFormat;	
	global int $boolEnvironment;
	global int $boolAllShadows;
	global string $renderStyle;	
	global string $renderEdgeStyle;
	global string $renderFillStyle;

	global vector $midPoint;
	global vector $fillLightPosition;
	global vector $corner1;						//Esquina 1 de la Bounding Box
	global vector $corner2;						//Esquina 2 de la Bounding Box


	//Se quita el estado de referencia al cubo, porque de otra manera, no saldría como fondo en el renderizado. En su lugar, salía el fondo negro.
	setAttr "CubeShape.template" 0;


	//Get current camera to render it
	string $panel = "modelPanel4";
	string $whichCam = `modelPanel -q -camera $panel`;





	if ($renderStyle == "realistic"){
		renderConfig("mentalray");	// + PARÁMETROS: dimensiones, formato

		renderIntoNewWindow render;



	} else if ($renderStyle == "cartoon"){
		renderConfig("mayasoftware");// + PARÁMETROS: dimensiones, formato

		//$fillStyle : "SingleColor", "TwoColor", "FourColor", "FullColor", "AverageColor", "AreaGradient", "MeshGradient", "None"
		//$edgeStyle : "Outline", "EntireMesh", "None"
		//string $fillStyle;
		//string $edgeStyle;

		//renderVector($whichCam, $fillStyle, $edgeStyle);
		renderVector($whichCam, $renderFillStyle, $renderEdgeStyle);

		renderIntoNewWindow render;



	} else if ($renderStyle == "vector"){
		renderConfig("mayasoftware");// + PARÁMETROS: dimensiones, formato

		renderVector($whichCam, "SingleColor", "None");

		renderIntoNewWindow render;



	} else if ($renderStyle == "caustics"){	

		/********************************************************
			Especialmente pensado para tener activado carcass
		********************************************************/


		//Configuración de Mental Ray
		renderConfig("mentalray");// + PARÁMETROS: dimensiones, formato

		//Caustics settings
		setAttr "miDefaultOptions.caustics" 1;		
		setAttr "miDefaultOptions.causticAccuracy" 10;
		setAttr "miDefaultOptions.finalGather" 1;





		//Configuración de la luz
		hide "Key_Light";
		string $light = "Fill_Light";


		setAttr ($light+"Shape.emitPhotons") 1;														//Ponemos la luz a emitir fotones
		//setAttr ($light+"Shape.decayRate") 2;		//Quadratic										//Ponemos su decay rate en quadratic. NO DECAY.
		setAttr ($light+"Shape.decayRate") 0;		//no decay

		setAttr ($light+"Shape.photonIntensity") 10000;	//20000	//Esto hay siempre que cambiarlo. Tutorial dice que 80.000 es muy poco. Lo pone a 300.000
		setAttr ($light+"Shape.intensity") 1;		//0.3 	//Que dependa de la bounding box

		setAttr ($light+"Shape.causticPhotons") 10000;	//10000. Calidad de imagen.
		//setAttr ($light+"Shape.useRayTraceShadows") 1;
		setAttr ($light+"Shape.useRayTraceShadows") 0;
		//Poner Fill_Light en el centro
		setAttr ($light+".translateX") ($midPoint.x);
		setAttr ($light+".translateY") ($midPoint.y);
		setAttr ($light+".translateZ") ($midPoint.z);





		//Render con MentalRay
		renderConfig("mentalray");
		renderIntoNewWindow render;





		//Restaurar las luces y el resto de la escena
		setAttr ($light+"Shape.emitPhotons") 0;												//Desactivamos la emisión de fotones de la luz
		
		setAttr ($light+".translateX") ($fillLightPosition.x);								//Poner Fill_Light en su posición habitual
		setAttr ($light+".translateY") ($fillLightPosition.y);
		setAttr ($light+".translateZ") ($fillLightPosition.z);

		showHidden "Key_Light";																//Volver a mostrar Key_Light
	}


	//Vuelve a referenciarse el cubo, puesto que se termina así el renderizado.
	setAttr "CubeShape.template" 1;

}






/********** playRotation() **********/
/*
Description: Cambia la cámara actual por la Spin_Camera y se inicia la rotación de la molécula.
29 Augu
*/
global proc playRotation(){
	global string $spinCameraName;

	//Get the actual camera
	string $panel = "modelPanel4";
	string $whichCam = `modelPanel -q -camera $panel`;

	if ($whichCam != $spinCameraName){
		//Cambiarla por Spin_Camera
		lookThroughModelPanel $spinCameraName $panel;
	}

	if (`play -q -state` == 0){
		//Press play if it's not already playing
		play ;
	}
}




/********** stopRotation() **********/
/*
Description: Para la rotación de la molécula
29 Augu
*/
global proc stopRotation(){
	if (`play -q -state` == 1){
		play -state 0 ;
	}
}








/********** drawCube() **********/
/*
Description: Dibuja un cubo que recubre la molécula, para poder tener efectos de sombras en el renderizado y visualizado
16 aug
*/
global proc drawCube(){
	global float $sceneWidth;
	global float $sceneHeight;
	global vector $corner1;
	global vector $corner2;
	global vector $midPoint;
	global vector $topCameraInitPos;
	global float $cubeColor[];


	string $cubeName = "Cube";

	//float $cubeHeight = $sceneHeight + 200;
	float $cubeHeight = $sceneHeight;
	float $cubeWidth = $sceneWidth + 500;
	float $cubeDepth = $sceneWidth + 500;


	//Creación
	polyCube -ch on -o on -w $cubeWidth -h $cubeHeight -d $cubeDepth -cuv 4 -name $cubeName ;


	//Traslación de su pivot hasta la cara del suelo
	move -r 	0 (-($cubeHeight/2)) 0 		($cubeName+".scalePivot") ($cubeName+".rotatePivot") ;

	//Translación
	setAttr "Cube.translateX" ($midPoint.x);
	//setAttr "Cube.translateY" ($cubeHeight/2 - $sceneHeight);	
	//Para dejar una distancia mínima entre el punto más bajo de la molécula y la cara del suelo del cubo
	setAttr "Cube.translateY" ($corner1.y);
	setAttr "Cube.translateZ" ($midPoint.z);
	setAttr "Cube.scaleY" 9;	//Para agrandar la altura del cubo, sin dejar que la molécula esté casi a ras de suelo




	//Color y material
	$cubeColor = {120, 120, 120}; 	//medianamente blanco
	//float $color[] = {170, 128, 100};  beige

	string $shaderName = "cube_Shader";
	assignShader($shaderName, $cubeColor, $cubeName);

	//Cambiar el tipo de material del shader de Blinn a Lambert, puesto que Lambert refleja menos las luces
	changeMaterial($shaderName, "lambert");

	


	//Bevel para redondear las aristas
	polyBevel -offset 0.5 -offsetAsFraction 1 -autoFit 1 -segments 12 -worldSpace 1 -uvAssignment 0 -fillNgons 1 -mergeVertices 1 -mergeVertexTolerance 0.0001 -smoothingAngle 90 -miteringAngle 180 -angleTolerance 180 -ch 1 Cube;




	//Una vez tenemos calculadas las dimensiones del cubo, les damos valores máximos y mínimos a las cámaras
	transformLimits -tz (-$cubeDepth/2 + 30) ($cubeDepth/2 - 30) -etz 1 1 "Front_Camera";
	transformLimits -tz (-$cubeDepth/2 + 30) ($cubeDepth/2 - 30) -etz 1 1 "Back_Camera";
	transformLimits -tx (-$cubeWidth/2 + 30) ($cubeWidth/2 - 30) -etx 1 1 "Left_Camera";
	transformLimits -tx (-$cubeWidth/2 + 30) ($cubeWidth/2 - 30) -etx 1 1 "Right_Camera";
	//La Spin_Camera ya tiene sus límites
	transformLimits -ty (0) ($topCameraInitPos.y) -ety 1 1 "Top_Camera";



	//Añadir el cubo a una nueva capa y ponerla en modo Referencia, para que el usuario no pueda seleccionarlo
	// createNode displayLayerManager -n "layerManager";
	// createDisplayLayer -mc -name "cubeLayer";
	// select "Cube";
	// editDisplayLayerMembers -noRecurse cubeLayer "Cube";
	// setLayerTo all".displayType" 2;
	// select -clear;

	setAttr "CubeShape.template" 1;

}






/********** setInterface() **********/
/*
Aug 24
Descripción: Carga la primera parte de la interfaz, que es la Shelf.
*/
global proc setInterface(){


												/* Objetos del ModelPanel4 */

	//Ocultar todo y mostrar sólo los tipos de objeto que interesa
	modelEditor -e -allObjects 1 modelPanel4;
	

	modelEditor -e -lights false modelPanel4;
	modelEditor -e -cameras false modelPanel4;
	modelEditor -e -nurbsCurves false modelPanel4;
	modelEditor -e -cv false modelPanel4;
	modelEditor -e -hud false modelPanel4;



											/* Cerrar todos los elementos de la interfaz excepto la Shelf */
	HideUIElements;	//ShowUIElements;

	if (! `isUIComponentVisible("Shelf")`){
		toggleUIComponentVisibility "Shelf";
	};
	//Poner el nombre de la cámara actual en el viewport.




														/* Model Panel Bar */

	modelPanelBarToggleButtonCallback("MayaWindow|formLayout1|viewPanes|modelPanel4|modelPanel4|modelEditorIconBar|flowLayout6", 0);
	modelPanelBarToggleButtonCallback("MayaWindow|formLayout1|viewPanes|modelPanel4|modelPanel4|modelEditorIconBar|flowLayout6", 2);
	//Mantener el 4, que es el de wireframe, etc
	modelPanelBarToggleButtonCallback("MayaWindow|formLayout1|viewPanes|modelPanel4|modelPanel4|modelEditorIconBar|flowLayout6", 6);
	//Mantener el 8, que es el Isolate selection
	modelPanelBarToggleButtonCallback("MayaWindow|formLayout1|viewPanes|modelPanel4|modelPanel4|modelEditorIconBar|flowLayout6", 10);



														/* Update Interface */

	evalDeferred("updateEditorToggleCheckboxes()");
	updateEditorToggleCheckboxes();
















														/* Shelf Items */

	global string $cpk = "cpk";
	global string $secondaryst = "secondary";
	global string $ballandstick = "ballandstick";
	global string $stick = "stick";
	global string $wire = "wire";



	if (`shelfLayout -exists scriptsShelf `) deleteUI scriptsShelf;



	global string $gShelfTopLevel;
	global string $scriptsShelf;

	string $UITemplate = "myUITemplates";
	global string $shelfName;
	$shelfName = `shelfLayout -cellWidth 110 -cellHeight 110 -p $gShelfTopLevel "ProteinViewer"`;




			string $button1 = `shelfButton
			     -parent $shelfName
			     -label "Open PDB file"
			     -al "center"
			     -annotation "Choose a PDB file to display a molecule. Those can be found at: http://www.rcsb.org/"
			     -style "iconAndTextVertical"
			     -image1 "open.png"
			     -command "openPDB()"
			`;


			string $b1Command = "drawCPK($secondaryst)";
			string $button1 = `shelfButton
			     -parent $shelfName
			     -label "Secondary Structure"
			     -al "center"
			     -annotation "Displays the molecule in Secondary Structure mode."
			     -style "iconAndTextVertical"
			     -image1 "secondary80.png"
			     -command $b1Command
			`;


			string $b2Command = "drawCPK($cpk)";
			string $button2 = `shelfButton
			     -parent $shelfName
			     -label "CPK"
			     -annotation "Displays the molecule in CPK mode."
			     -style "iconAndTextVertical"
   			     -image1 "cpk80.png"
			     -command $b2Command
			`;


			string $b3Command = "drawCPK($ballandstick)";
			string $button3 = `shelfButton
			     -parent $shelfName
			     -label "Ball & Stick"
			     -annotation "Displays the molecule in Ball & Stick mode."
			     -style "iconAndTextVertical"
			     -image1 "ballandstick80.png"
			     -command $b3Command
			`;


			string $b4Command = "drawCPK($stick)";
			string $button4 = `shelfButton
			     -parent $shelfName
			     -label "Stick"
			     -annotation "Displays the molecule in Stick mode, in which bonds and atoms have the same radius."
			     -style "iconAndTextVertical"
			     -image1 "stick80.png"
			     -command $b4Command
			`;	


			string $b5Command = "drawCPK($wire)";
			string $button5 = `shelfButton
			     -parent $shelfName
			     -label "Wire"
			     -annotation "Displays the molecule in Wire mode."
			 	 -style "iconAndTextVertical"
			     -image1 "wire_80_good.png"
			     -command $b5Command
			`;



			string $button6 = `shelfButton
			     -parent $shelfName
			     -label "Display"
			     -annotation "Shows display controls. Allows you to choose how to display the molecule."	
			     -style "iconAndTextVertical"
			     -image1 "display80.png"
			     -command "drawDisplayWindow()"
			`;


			string $button7 = `shelfButton
			     -parent $shelfName
			     -label "Structure"
			     -annotation "Shows structure controls. Allows you to choose which parts of the molecule to see and which to hide."	
			     -style "iconAndTextVertical"
			     -image1 "structure80.png"
			     -command "drawStructureWindow()"
			`;



			string $button8 = `shelfButton
			     -parent $shelfName
			     -label "Cameras"
			     -annotation "To change the molecule's current view."	
			     -style "iconAndTextVertical"
			     -image1 "camera80.png"
			     -command "drawCamerasWindow()"
			`;


			string $button8 = `shelfButton
			     -parent $shelfName
			     -label "Lights"
			     -annotation "Controls to change the different lights present in the scene."	
			     -style "iconAndTextVertical"
			     -image1 "lights.png"
			     -command "drawLightsWindow()"
			`;


			string $button10 = `shelfButton
			     -parent $shelfName
			     -label "Rendering"
			     -annotation "Obtain photorealistic, vectorized or cartoon images of the molecule."	
			     -style "iconAndTextVertical"
			     -image1 "rendering.png"
			     -command "drawRenderingWindow()"
			`;


			string $button11 = `shelfButton
			     -parent $shelfName
			     -label "Molecule info"
			     -annotation "Want to know more about this molecule?"	
			     -style "iconAndTextVertical"
			     -image1 "molecule info.png"
			     -command "drawInformationWindow()"
			`;	



	optionVar -iv saveActionsPreferences false;			//Que nunca guarde las preferencias actuales al cerrar Maya
	//string $command = "setWireframeOnShadedOption false modelPanel4; DisplayShadedAndTextured;";

	if (`grid -q -toggle` == 1){
		grid -toggle 0;
	}


}






global proc interfacePart2(){



										/* Interactive Shading */
	//Interactive shading debería estar desactivado, de lo contrario al mover la escena se ve en wireframe
	toggleInteractiveShading false modelPanel4;





										/* Set shaded display options */
	DisplayShadedAndTextured;
	setWireframeOnShadedOption false modelPanel4;
	setWireframeOnShadedOption false modelPanel4;
	displayPref -wireframeOnShadedActive "reduced";
	displayPref -shadeTemplates 1;	//¿?

	//Activa el display del nombre de la cámara actual en el viewport
	ToggleCameraNames 1;

	//Si se ha abierto el Att editor, lo cierra
	if ( `isUIComponentVisible("Attribute Editor")`){
		toggleUIComponentVisibility "Attribute Editor";
	};
}









global proc drawRenderingWindow(){
	global string $renderStyle;
	global int $edgeAndFillTime;
	string $myWindow = `window`;	// Principal






	columnLayout;
		frameLayout -collapsable false "Resolution";
		string $reso = `radioButtonGrp -numberOfRadioButtons 4
								-l "Choose one: "		
								-labelArray4 "HD 1080 (1920x1080)" "HD 720 (1280x720)" "HD 540 (960x540)" "Low (320x240)"
								-on1 "$renderWidth = 1920; $renderHeight = 1080; "
								-on2 "$renderWidth = 1280; $renderHeight = 720; "
								-on3 "$renderWidth = 960; $renderHeight = 540; "
								-on4 "$renderWidth = 320; $renderHeight = 240; "
								-columnWidth4 100 100 100 100
								-vr
								-w 390
								`;
		setParent ..;




		frameLayout -collapsable false "Image format";
		string $form = `radioButtonGrp -numberOfRadioButtons 2
								-l "Choose one: "		
								-labelArray2 "PNG" "JPG"
								-on1 "$renderFormat = 32"
								-on2 "$renderFormat = 31"
								-columnWidth2 100 100
								-vr
								-w 390
								`;
		setParent ..;




		frameLayout -collapsable false "Activate / Deactivate";
			rowLayout -nc 2;
				checkBox -l "Shadows" -onc "deactivateShadows(0)" -ofc "deactivateShadows(1)" -v 1;
				checkBox -l "Environment" -onc "showHidden Cube" -ofc "hide Cube" -v 1;
		setParent ..;



		frameLayout -collapsable false "Rendering style";
		string $rende = `radioButtonGrp -numberOfRadioButtons 4
								-l "Choose one: "
								-labelArray4 "Realistic" "Vector" "Cartoon" "Caustics"
								-on1 "$renderStyle = \"realistic\""
								-on2 "$renderStyle = \"vector\"" 
								-on3 "$renderStyle = \"cartoon\"; 	showEdgeAndFillOptions(); " 
								-on4 "$renderStyle = \"caustics\"" 
								-columnWidth4 100 100 100 100
								-columnAttach4 "right" "right" "right" "right" 
								-columnOffset4 20 20 20 20
								-vr
								-w 390
								`;
		setParent ..;








		button -l "Start render" -c "render($renderStyle)";
		setParent..;









	dockControl 
		-content $myWindow
		-l "Rendering"
		-area "right"
		-allowedArea "right"
		-w 400
		-s 0
	;

}




global proc showEdgeAndFillOptions(){
	//para que sólo lo imprima una vez
	//Gracias a -shareCollection, ambos radioButtonGrps están conectados, pudiendo elegir entre 8 opciones.

	global int $edgeAndFillTime;

	if ($edgeAndFillTime == 1){
		//$fillStyle : "SingleColor", "TwoColor", "FourColor", "FullColor", "AverageColor", "AreaGradient", "MeshGradient", "None"
		//$edgeStyle : "Outline", "EntireMesh", "None"
		frameLayout -collapsable false "Edge style";
		string $edgesty = `radioButtonGrp -numberOfRadioButtons 3
								-l "Choose one: "
								-labelArray3 "Outline" "Entire mesh" "None"
								-on1 "$edgeStyle = \"Outline\""
								-on2 "$edgeStyle = \"EntireMesh\"" 
								-on3 "$edgeStyle = \"None\"" 
								-columnWidth3 100 100 100 
								-vr
								-w 390
								`;
		setParent ..;	


		frameLayout -collapsable false "Fill style";


		string $fillsty1 = `radioButtonGrp -numberOfRadioButtons 4
								-l "Choose one: "
								-labelArray4 "Single color" "Two colors" "Four colors" "Full color" 
								-on1 "$fillStyle = \"SingleColor\""
								-on2 "$fillStyle = \"TwoColor\"" 
								-on3 "$fillStyle = \"FourColor\"" 
								-on4 "$fillStyle = \"FullColor\"" 
								-columnWidth4 100 100 100 100
								-vr
								-w 390
								`;

		string $fillsty2 = `radioButtonGrp -numberOfRadioButtons 4 
								-shareCollection $fillsty1
								-l ""
								-labelArray4 "Average color" "Area gradient" "Mesh gradient" "None"
								-on1 "$fillStyle = \"AverageColor\""
								-on2 "$fillStyle = \"AreaGradient\"" 
								-on3 "$fillStyle = \"MeshGradient\"" 
								-on4 "$fillStyle = \"None\"" 
								-columnWidth4 100 100 100 100
								-vr
								-w 390
								`;
		setParent ..;
	}

	$edgeAndFillTime = $edgeAndFillTime + 1;
}






global proc drawLightsWindow(){
	global string $keyLightName, $fillLightName, $backLightName;
	string $myWindow = `window`;
	global string $lightToModify;

	$lightToModify = $keyLightName;





	columnLayout;
		frameLayout -collapsable false -l "Scene lights" -mh 20 -lv 0 -w 390;
		global string $form;
		$form = `radioButtonGrp -numberOfRadioButtons 3
								-l "Choose one light:      "
								-labelArray3 "Main light" "Fill light" "Back light"
								-on1 "$lightToModify = $keyLightName; print($lightToModify); "
								-on2 "$lightToModify = $fillLightName; print($lightToModify);"
								-on3 "$lightToModify = $backLightName;  print($lightToModify);"
								-select 1
								-columnWidth3 90 90 90
								-w 390
								-vr `;
		setParent ..;








		frameLayout -collapsable false -l "Activation" -lv 0 -w 390;
			rowLayout -nc 1;
			checkBox -l "Activate / Deactivate light" -onc "showHidden $lightToModify" -ofc "hide $lightToModify" -w 390;
		setParent ..;








		frameLayout -collapsable false -l "Properties" -w 390;


		frameLayout -collapsable false -l "Intensity" -lv 0 -w 390;
			rowLayout -nc 1;
			float $currentValue = getAttr($lightToModify+".intensity");
				floatSliderGrp 
					-l "Intensity      "
					-f 1
					-cal 1 "center"								
					-min 0
					-max 3
					-fieldMinValue 0
					-fieldMaxValue 3
					-value $currentValue
					-cc "float $inten = getFloatFromSlider(\"intensitySlider\"); print $inten; changeLightsIntensity($lightToModify, $inten); "
					"intensitySlider"
					;
		setParent ..;









		frameLayout -collapsable false -l "Light color" -lv 0 -w 390;
	 	       colorSliderButtonGrp
			        -label "Light color"
			        -buttonLabel "Set"
			        -rgb 1 0 0
			        -bc "float $c[] = getColorFromSlider(\"colorSlider\"); setAttr($lightToModify+\"Shape.color\") $c[0] $c[1] $c[2]; "
			        "colorSlider"
			        ;
		setParent ..;






		frameLayout -collapsable false -l "Position" -lv 0 -w 390;
			rowLayout -nc 1;
				intSliderGrp 
					-l "Move closer / away"
					-f 1
					-min -100
					-max 100
					-value 0
					-cc "int $uno = getIntFromSlider(\"positionSlider\"); moveLights($uno);"
					"positionSlider"
					;
		setParent ..;










		frameLayout -collapsable false -l "Shadows" -w 390;
			frameLayout -collapsable false -l "Shadows color" -lv 0 -w 390;
		 	       colorSliderButtonGrp
					        -label "Shadow color"
					        -buttonLabel "Set"
					        -rgb 1 0 0
					        -bc "float $c[] = getColorFromSlider(\"shadowSlider\"); setAttr($lightToModify+\"Shape.shadowColor\") $c[0] $c[1] $c[2]"
					        "shadowSlider";
			setParent ..;


			rowLayout -nc 1;
				checkBox -l "Cast shadow" 
					-onc "deactivateShadows(0)" 
					-ofc "deactivateShadows(1)"
					-w 390;
		setParent ..;




	button -l "Restore light" -c "restoreLight($lightToModify)" -w 20;
	setParent ..;




	dockControl 
		-content $myWindow
		-l "Lights"
		-area "right"
		-allowedArea "right"
		-w 400
		-s 0
	;
}








/*29 Aug-30 Aug*/
global proc drawCamerasWindow(){
// 	PLAY timeplay.png
// STOP timestop.png
// forward timefwd.png
// rewind timerew.png
	global string $frontCameraName;
	global string $backCameraName;
	global string $leftCameraName;
	global string $rightCameraName;
	global string $topCameraName;
	global float $stickRadius;

	global int $numberOfHeterogens;


	string $myWindow = `window`;






	frameLayout -collapsable true -l "RotationFrameLayout" -lv 0;
		frameLayout -collapsable true -l "Select camera" -w 390 -marginHeight 1 -lv 1 "cameraLayout";
			rowColumnLayout -numberOfRows 1 -columnSpacing 1 8 -columnSpacing 2 8 -columnOffset 1 "left" (50+128) -rowOffset 1 "top" 100;
				button -l "Top" -w 40 -c "activateCamera($topCameraName)" ; 
				button -l "Back" -w 40 -c "activateCamera($backCameraName)" ;
			setParent ..;


			rowColumnLayout -numberOfRows 1 -columnSpacing 1 8 -columnSpacing 2 8 -columnOffset 1 "left" (130) ;
				button -l "Left" -w 40 -c "activateCamera($leftCameraName)" ; 
				button -l "Front" -w 40 -c "activateCamera($frontCameraName)" ; 
				button -l "Right" -w 40 -c "activateCamera($rightCameraName)" ;
			setParent ..;


			rowColumnLayout -numberOfRows 1 -columnOffset 1 "both" 100 -rowOffset 1 "bottom" 100;	//-rowSpacing 30	-columnAlign "center"
				button -l "Restore position" -w 200 -c "restoreCurrentCameraPosition()" ;
			setParent ..;
		setParent ..;
	setParent ..;
	frameLayout -e -w 390 -h 300 "cameraLayout";	//para que se comporte mejor al colapsar












	frameLayout -collapsable true -l "Rotation controls" -w 390  -marginHeight 1 -lv 1 "rotationLayout";
		rowColumnLayout -numberOfRows 1 -columnSpacing 1 8 -columnSpacing 2 8 -columnOffset 1 "left" (150) -rowOffset 1 "top" 5;
			iconTextButton -label "rewind" -style "iconOnly" -image1 "timerew.png" -c "decreaseAnimationSpeed()" ; 
			iconTextButton -label "play" -style "iconOnly" -image1 "timeplay.png" -c "playRotation()" ; 
			iconTextButton -label "forward" -style "iconOnly" -image1 "timefwd.png" -c "increaseAnimationSpeed()";
		setParent ..;


		rowColumnLayout -numberOfRows 1 -columnSpacing 1 8 -columnSpacing 2 8 -columnOffset 1 "left" (31+150) -rowOffset 1 "bottom" 100;
			iconTextButton -label "stop" -style "iconOnly" -image1 "timestop.png" -c "stopRotation()";
		setParent ..;
	setParent ..;
	frameLayout -e -w 390 -h 120 "rotationLayout";	//para que se comporte mejor al colapsar











									/***** Cameras HETATM *****/

	global string $cameras[];
	$cameras = `ls -cameras "Camera_Residue_*"`;	//Camera_Residue_A_154_SO4

	global string $cam;





	frameLayout -collapsable true -l "Non-standard residues" -w 390 -lv 1 "hetatmLayout";
		global string $myCollection;
		$myCollection = `radioCollection `;

		for ($i=0; $i<size($cameras); $i++){
			// button label: nombre de la cámara
			string $cn = `substring $cameras[$i] 1 (size($cameras[$i])-5)  `;
			string $label = `getCameraNiceName($cn)`;


			//Creación de los botones:
			//-label: nombre legible por el usuario			
			//-ann: nombre real de la cámara
			string $buttonResponse = `radioButton  
										-l $label
										-ann $cn
										-width 200
										-onc "string $current = getSelectedFromCollection($myCollection); string $label = getLabelFromSelected($current); lookThroughModelPanel $label modelPanel4; "
										`;

			string $textResponse = `radioButton -q $buttonResponse`;	
			//print $textResponse;
		}
	setParent ..;						






	dockControl 
		-content $myWindow
		-l "Cameras"
		-area "right"
		-allowedArea "right"
		-w 400
		-s 1
		-epo 1
	;
}








/*30 Aug - 2 Sept*/
global proc drawStructureWindow(){
	global string $lastChar;	//Letra de la última cadena
	global string $alphabet[], $nucleotides[];

	global int $numberOfSheets, $numberOfHelixes, $numberOfChains, $numberOfResidues, $numberOfSceneResidues, $numberOfElements;
	global int $numberOfAtoms, $numberOfHeterogens, $numberOfAtms, $numBonds, $numberOfSlabs;
	global int $keepChainTraces, $keepCarcass, $keepSheets, $keepHelixes;
	global int $numberOfHeterogens, $isThereDNA, $isBallAndStickFull;	

	global string $sceneResidues[], $sceneStandardResidues[], $sceneNonStandardResidues[], $sceneNonStandardResiduesNiceNames[], $sceneElements[], $sceneStrandIDs[];
	global int $helixClass[];
	int $nStandRes = size($sceneStandardResidues);
	int $nNonRes = size($sceneNonStandardResidues);

	string $temp1[] = `sort $sceneNonStandardResidues`;
	$sceneNonStandardResidues = $temp1;
	string $temp2[] = `sort $sceneStandardResidues`;
	$sceneStandardResidues = $temp2;



	string $myWindow = `window`;



																		/****** SHOW ALWAYS ******/
	columnLayout;
		frameLayout -collapsable true -l "Show in every mode" -w 390 -lv 1 "showAlways";
			rowColumnLayout -numberOfRows 2 -columnSpacing 1 20 -columnSpacing 2 20 ;

				checkBox -l "Chain trace" 		-onc "$keepChainTraces = 1; showAllChainTraces(1);" 		-ofc "$keepChainTraces = 0; showAllChainTraces(0); " 	-v 0;

				checkBox -l "Carcass" 			-onc "$keepCarcass = 1; 	drawCarcass(); " 			-ofc "$keepCarcass = 0; 	showCarcass(0); " 		-v 0;

				if ($numberOfHelixes > 0) checkBox -l "Helixes" 		-onc "$keepHelixes = 1; 	showHelixes(1); " 			-ofc "$keepHelixes = 0; 	showHelixes(0); " 		-v 0;

				if ($numberOfSheets > 0) checkBox -l "Sheets" 			-onc "$keepSheets = 1; 		showSheets(1); " 			-ofc "$keepSheets = 0; 		showSheets(0); " 		-v 0;

				if ($isThereDNA == 1) checkBox -l "Slabs" 				-onc "$keepSlabs = 1; 		showSlabs(1); " 			-ofc "$keepSlabs = 0;" 		-v 1;	//Los slabs se mantienen

		//Inicialmente, aparecen todas las casillas marcadas porque siempre se intenta dibujarlo todo.
		setParent ..;










																		/****** MOLECULAR STRUCTURE ******/

		frameLayout -collapsable true -l "Molecular structure" -w 390 -ann "Choose which parts to make visible or hide" -lv 1 "molecularStructure";
			frameLayout -collapsable true -l ("Chains: ("+$numberOfChains+")") -w 390 -lv 1 "chains";
				//total chains
				frameLayout -collapsable true -l ("Chains sub") -w 390 -lv 0 -mh 5 "chainssub";
					checkBox -l ("Total chains")		-onc "showAllChains(1);" 	-ofc "showAllChains(0); " 		-v 1;
				setParent ..;


				global string $str;
				$str = "";

				for ($i=0; $i<$numberOfChains; $i++){
					//checkBox -l ("Chain "+$alphabet[$i]) 	-onc "showChain($alphabet[\"+$i+\"], 1)"	-ofc "showChain($alphabet[\"+$i+\"], 0)"	-v 1;
					$str = $str + (" checkBox -l (\"Chain \"+$alphabet["+$i+"]) 	-onc \" showChain($alphabet["+$i+"], 1); \"			-ofc \" showChain($alphabet["+$i+"], 0); \"			-v 1; ");
																					//también: showChain( \""+$alphabet[$i]+"\" )
				}

				eval ($str);
			setParent ..;	













			frameLayout -collapsable true -l ("Residues: "+$numberOfResidues+" in total, of which, "+$numberOfSceneResidues+" are distinct") -w 390 -lv 1 "residues";

				global string $standardRes, $nonStandardRes; 
				$standardRes = $nonStandardRes = "";


																			/***** NON STANDARD RESIDUES *****/
				if ($numberOfHeterogens > 0){
					for ($i=0; $i<size($sceneNonStandardResidues); $i++){
						// Marcarlos,  (menos el HOH), son los únicos que se muestran al principio
						string $full = $sceneNonStandardResiduesNiceNames[$i];	//Los nice names no estándar los tengo ya en un vector procesados

						if ($sceneNonStandardResidues[$i] == "HOH"){
							//Desmarcar HOH
							$nonStandardRes = $nonStandardRes + (" checkBox -l (\""+$full+"\")	 -onc \" showResidue($sceneNonStandardResidues["+$i+"], 1); \"	-ofc \" showResidue($sceneNonStandardResidues["+$i+"], 0); \"	-v 0; ");					
						} else {
							//Marcarlos
							$nonStandardRes = $nonStandardRes + (" checkBox -l (\""+$full+"\")	 -onc \" showResidue($sceneNonStandardResidues["+$i+"], 1); \"	-ofc \" showResidue($sceneNonStandardResidues["+$i+"], 0); \"	-v 1; ");					
						}
					}


					frameLayout -collapsable true -l ("Non-standard residues: ("+$nNonRes+")") -w 390 -lv 1 "nonstandardresidues";
						eval ($nonStandardRes);
					setParent ..;
				}





																			/***** STANDARD RESIDUES *****/
				for ($i=0; $i<size($sceneStandardResidues); $i++){
					// Desmarcarlos, ya que no se muestran al principio
					string $name = $sceneStandardResidues[$i];	
					string $full = getResiduesNiceNames($name);


					if ($isBallAndStickFull == 0){
						$standardRes = $standardRes + (" checkBox -l (\""+$full+"\") -onc \" showResidue($sceneStandardResidues["+$i+"], 1); \"	-ofc \" showResidue($sceneStandardResidues["+$i+"], 0); \"		-v 0; ");
					} else {
						$standardRes = $standardRes + (" checkBox -l (\""+$full+"\") -onc \" showResidue($sceneStandardResidues["+$i+"], 1); \"	-ofc \" showResidue($sceneStandardResidues["+$i+"], 0); \"		-v 1; ");
					}


				}	
	
				frameLayout -collapsable true -l ("Standard residues: ("+$nStandRes+")") -w 390 -lv 1 -collapse 1 "standardresidues";	//Mostrar colapsado, que suele tener muchos elementos
					eval ($standardRes);
				setParent ..;	
			setParent ..;	












																			/***** ELEMENTS *****/
			//$sceneElements[], $numberOfElements;
			frameLayout -collapsable true -l ("Elements: ("+$numberOfElements+")") -w 390 -lv 1 "elements";

				global string $els;
				$els = "";

				for ($i=0; $i<$numberOfElements; $i++){
					string $short = $sceneElements[$i];
					//$alphabet["+$i+"]
					string $long = getElementsNiceNames( $short );
					$els = $els + (" checkBox -l (\""+$long+"\") 	-onc \" showElement($sceneElements["+$i+"], 1); \"			-ofc \" showElement($sceneElements["+$i+"], 0); \"			-v 1; ");
				}

				eval ($els);
			setParent ..;	









																			/***** ALL ATOMS *****/
			frameLayout -collapsable true -l ("Atoms: ("+$numberOfAtoms+")") -w 390 -lv 1 "atoms";
					frameLayout -collapsable true -l ("Atoms sub") -w 390 -lv 0 -mh 5 "atomssub";
						checkBox -l ("All atoms") 			-onc "showAllAtoms(1);" 	-ofc "showAllAtoms(0); " 		-v 0;
					setParent ..;	

						checkBox -l ("Atoms: ("+$numberOfAtms+")") 					-onc "showAtoms(1);" 		-ofc "showAtoms(0); " 		-v 0;
						checkBox -l ("Heterogens: ("+$numberOfHeterogens+")") 		-onc "showHetatms(1);" 		-ofc "showHetatms(0); " 	-v 1;
			setParent ..;	









																			/***** ALL BONDS *****/
			frameLayout -collapsable true -l ("Bonds: ("+$numBonds+")") -w 390 -lv 1 -mh 5 "bonds";
					checkBox -l ("All bonds") 			-onc "showBonds(1);" 	-ofc "showBonds(0); " 		-v 0;
			setParent ..;	










																			/***** CHAIN TRACES *****/
			frameLayout -collapsable true -l ("Chain traces: ("+$numberOfChains+") ") -w 390 -lv 1 "chaintraces";
					frameLayout -collapsable true -l ("Chaint sub") -w 390 -lv 0 -mh 5 "chaintracessub";
						checkBox -l ("All chain traces ") 			-onc "showAllChainTraces(1);" 	-ofc "showAllChainTraces(0); " 		-v 1;
					setParent ..;	




					global string $ct;
					$ct = "";

					for ($i=0; $i<$numberOfChains; $i++){
						string $letter = $alphabet[$i]; //coger de Chains
						$ct = $ct + (" checkBox -l (\"Chain trace "+$letter+"  \") 	-onc \" showChainTrace($alphabet["+$i+"], 1); \"		-ofc \" showChainTrace($alphabet["+$i+"], 0); \"		-v 1; ");
					}

					eval ($ct);
			setParent ..;	











																			/***** BACKBONE *****/
			frameLayout -collapsable true -l ("Backbone ") -w 390 -lv 1 "backbone";
					frameLayout -collapsable true -l ("Backbone sub") -w 390 -lv 0 -mh 5 "backbonesub";
						button -l ("Whole molecule ") 			-c "showWholeMolecule();" -w 390;
					setParent ..;	

					rowColumnLayout -numberOfColumns 3 -columnSpacing 1 8 -columnSpacing 2 8 -columnSpacing 3 8 -columnOffset 1 "left" (1) -rowOffset 1 "bottom" 5;
						button -l ("Full backbone") 		-c "callToBackbone(\"full\");" 			-w 115;
						button -l ("Minimal backbone") 		-c "callToBackbone(\"minimal\");" 		-w 115;
						button -l ("Side chains") 			-c "callToBackbone(\"sidechains\");" 	-w 115;
					setParent ..;
		
			setParent ..;











			if ($numberOfHelixes > 0){
																			/***** HELIXES *****/
				frameLayout -collapsable true -l ("Helixes: ("+$numberOfHelixes+")") -w 390 -lv 1 "helixes";
					frameLayout -collapsable true -l ("Helixes sub ") -w 390 -lv 0 -mh 5 "helixsub";
						checkBox -l ("Total helixes: ("+$numberOfHelixes+")") 			-onc "showHelixes(1);" 	-ofc "showHelixes(0); " 		-v 1;
					setParent ..;



					global string $hel;
					$hel = "";

					for ($i=1; $i<=$numberOfHelixes; $i++){
						//GET TYPE
						int $n = $helixClass[$i-1];
						string $type = getHelixesNiceTypes( $n );	
						$hel = $hel + (" checkBox -l (\"Helix "+$i+": "+$type+" \") 	-onc \" showHelix("+$i+", 1); \"			-ofc \" showHelix("+$i+", 0); \"			-v 1; ");
					}

					eval ($hel);
				setParent ..;
			}

	










			if ($numberOfSheets > 0){
																			/***** SHEETS *****/
				frameLayout -collapsable true -l ("Sheets: ("+$numberOfSheets+")") -w 390 -lv 1 "sheets";
					frameLayout -collapsable true -l ("Sheets sub ") -w 390 -lv 0 -mh 5 "sheetsub";
						checkBox -l ("Total sheets: ("+$numberOfSheets+")") 			-onc "showSheets(1);" 	-ofc "showSheets(0); " 		-v 1;
						checkBox -l ("Show strands senses") 	-onc "showHidden \"sense*\"; "	-ofc "hide \"sense*\"; "	-v 1;
					setParent ..;



					global string $she;
					$she = "";

					for ($i=0; $i<$numberOfSheets; $i++){ 
						int $j = $i+1;
						$she = $she + ("checkBox -l (\"Sheet "+$j+" \")	-onc \" showSheet($sceneStrandIDs["+$i+"], 1); \"		-ofc \" showSheet($sceneStrandIDs["+$i+"], 0); \"			-v 1; ");
					}

					eval ($she);
				setParent ..;
			}








			if ($isThereDNA == 1){

																				/***** SLABS *****/
				frameLayout -collapsable true -l ("Slabs: ("+$numberOfSlabs+")") -w 390 -lv 1 "slabs";
						frameLayout -collapsable true -l ("Slabs sub") -w 390 -lv 0 -mh 5 "slabssub";
							checkBox -l ("Total slabs") 			-onc "showSlabs(1);" 	-ofc "showSlabs(0); " 		-v 1;
						setParent ..;	




						global string $sla;
						$sla = "";

						for ($i=0; $i<size($nucleotides); $i++){
							string $base = $nucleotides[$i]; //coger de Chains
							//int $baseCount = 1;
							int $bc = baseCount($base);	//función que te da el número de repeticiones de la base concreta
							$sla = $sla + (" checkBox -l (\"Slab "+$base+": ("+$bc+")  \") 	-onc \" showSlab($nucleotides["+$i+"], 1); \"		-ofc \" showSlab($nucleotides["+$i+"], 0); \"		-v 1; ");
						}

						eval ($sla);
				setParent ..;
			}







		setParent ..;
	dockControl 
		-content $myWindow
		-l "Structure"
		-area "right"
		-allowedArea "right"
		-w 400
		-s 1
		-epo 1
	;
}










global proc drawDisplayWindow(){
	global int $isThereCarcass;
	global float $stickRadius;
	global int $isThereDNA, $numberOfHelixes, $numberOfSheets;

	string $myWindow = `window`;

	columnLayout;




		frameLayout -collapsable true -l "General options" -w 390 -lv 1 "molecule";



				frameLayout -collapsable true -l "Stick mode" -w 390 -lv 1  "stickradiussub";
					rowColumnLayout -numberOfRows 2 ;
						floatSliderGrp 
							-l "Radius: "
							-f 1
							-min 0.15
							-max 1.2
							-value $stickRadius
							-cc "$stickRadius = getFloatFromSlider(\"stickRadiusSlider\");  "
							"stickRadiusSlider"
							;
					rowColumnLayout -numberOfColumns 1 -columnSpacing 1 5 -columnOffset 1 "left" 100;
						button -l ("Stick mode") -c "drawCPK(\"stick\");"  -w 100;
				setParent ..;	
				setParent ..;	





				frameLayout -collapsable true -l "Chain trace display" -w 390 -lv 1  "ctdisplay";
					radioButtonGrp -numberOfRadioButtons 2
						-l "Choose one: "		
						-labelArray2 "Smooth" "Regular" 
						-on1 "hide \"*regularAminoacid*\"; 	$modeAminoacids = \"smoothAminoacid\"; 		showAllChainTraces(1);"
						-on2 "hide \"*smoothAminoacid*\";	if ($regularDrawn == 0) { drawChainTrace(\"regularAminoacid\", \"roundedDNA\"); } 	$modeAminoacids = \"regularAminoacid\"; showAllChainTraces(1); 	"
						-columnWidth2 100 100 
						-sl 1
						-vr
						-w 390
					;
				setParent ..;	
				setParent ..;
				setParent ..;
				//la smooth ya se dibujó al principio, así que sólo se mostraría





				frameLayout -collapsable true -l "Material" -w 390 -lv 1  "materialsub";
					radioButtonGrp -numberOfRadioButtons 3
						-l "Choose one: "		
						-labelArray3 "Blinn" "Phong" "Lambert"
						-on1 "changeAllMaterials(\"blinn\"); 	toggleUIComponentVisibility \"Attribute Editor\"; "
						-on2 "changeAllMaterials(\"phong\"); 	toggleUIComponentVisibility \"Attribute Editor\";"
						-on3 "changeAllMaterials(\"lambert\"); 	toggleUIComponentVisibility \"Attribute Editor\";"
						-columnWidth3 100 100 100 
						-sl 1
						-vr
						-w 390
					;
					//El attribute editor se abre solo al cambiar los materiales, así que lo cierro
				setParent ..;	










				frameLayout -collapsable true -l "Color" -w 390 -lv 1  "colorsub";
				 	colorSliderButtonGrp
				        -label "Whole molecule: "
				        -buttonLabel "Set"
				        -rgb 1 0 0
				        -bc "float $c[] = getColorFromSlider(\"monochromeSlider\"); colorMonochrome($c); "
				        "monochromeSlider"
			        ;
    				


					frameLayout -collapsable true -l "Group coloring" -w 390 -lv 1 "colorcpksub";
						rowColumnLayout -numberOfColumns 3 -columnSpacing 1 5 -columnSpacing 2 5 -columnSpacing 3 5 -columnOffset 1 "left" 2;
					        button -l ("Color by chemical element ") -ann "Only for atoms and bonds" -c "colorCPK();" -w 160;				//CPK Predeterminado
					        button -l ("Color by residue ") -c "colorResidues();"  -w 100;
					        button -l ("Color by chain ") -c "colorChains();"  -w 100;
	    				setParent ..;	
				setParent ..;	








				frameLayout -collapsable true -l "Chain traces" -w 390 -lv 1 "chaintraces";
					frameLayout -collapsable true -l ("Color") -w 390 -lv 0  "chaintracescolorsub";
					 	colorSliderButtonGrp
					        -label "Color: "
					        -buttonLabel "Set"
					        -rgb 1 0 0
					        -bc "float $c[] = getColorFromSlider(\"chaintraceSlider\"); 	colorChainTrace($c, 0); "
					        "chaintraceSlider"
				        ;			

						rowColumnLayout -numberOfColumns 1 -columnSpacing 1 5 -columnOffset 1 "left" 100;
							button -l ("Restore ") -ann "Default" -c "colorChainTrace($c, 1);" -w 100;				
						setParent ..;	
					setParent ..;
				setParent ..;








				frameLayout -collapsable true -l "Environment" -w 390 -lv 1 "environment";
					frameLayout -collapsable true -l ("Color") -w 390 -lv 0  "environmentsub";
					 	colorSliderButtonGrp
					        -label "Color: "
					        -buttonLabel "Set"
					        -rgb 0.5 0.5 0.5
					        -bc "float $c[] = getColorFromSlider(\"environmentSlider\"); 	setAttr(\"cube_Shader.color\") $c[0] $c[1] $c[2]; "
					        "environmentSlider"
				        ;			
					setParent ..;
				setParent ..;









		if ($numberOfHelixes > 0){
			frameLayout -collapsable true -l "Helices" -w 390 -lv 1 "helices";
					frameLayout -collapsable true -l ("Color") -w 390 -lv 1  "helicessub";
						rowColumnLayout -numberOfColumns 3 -columnSpacing 1 5 -columnSpacing 2 5 -columnSpacing 3 5 -columnOffset 1 "left" 30;
					        button -l "By type" -c "assignColorToAllHelixesByType();" -w 100;				
					        button -l "By chain" -c "assignColorToHelixByChain()"  -w 100;				
					        button -l "By number" -c "assignColorToAllHelixesByNumber()"  -w 100;	
		    		setParent ..;        		
    		setParent ..;
		}












		if ($numberOfSheets > 0){
			frameLayout -collapsable true -l "Sheets" -w 390 -lv 1 "sheets";
					frameLayout -collapsable true -l ("Monochrome") -w 390 -lv 1  "sheetssub";
							colorSliderButtonGrp
							        -label "Color: "
							        -buttonLabel "Set"
							        -bc "float $c[] = getColorFromSlider(\"sheetscolorslider\"); assignMonochromeToAllSheets($c); "
							        "sheetscolorslider"
						        ;
		    		setParent ..;        		
    		setParent ..;
		}










		if ($isThereCarcass == 1){
			frameLayout -collapsable true -l "Carcass" -w 390 -lv 1 "carcass";
					//Color
					colorSliderButtonGrp
				        -label "Color: "
				        -buttonLabel "Set"
				        -bc "float $c[] = getColorFromSlider(\"carcassColorSlider\"); setAttr(\"transparent_Shader.color\") $c[0] $c[1] $c[2]; "
				        "carcassColorSlider"
			        ;

					//Transparencia
					colorSliderButtonGrp
				        -label "Transparency: "
				        -buttonLabel "Set"
				        -bc "float $c[] = getColorFromSlider(\"carcassTransparencySlider\"); setAttr(\"transparent_Shader.transparency\") $c[0] $c[1] $c[2]; "
				        "carcassTransparencySlider"
			        ;
				
			setParent ..;
		}




		if ($isThereDNA == 1){
			//Cambiar el grosor de las bases
			//changeBasesWidth(float $rad). Mínimo de radio es 0.2.

			frameLayout -collapsable true -l "DNA" -w 390 -lv 1  "dnastructure";
				frameLayout -collapsable true -l "Stick mode" -w 390 -lv 1  "basessub";
						rowColumnLayout -numberOfRows 2 ;
							floatSliderGrp 
								-l "Bases width: "
								-f 1
								-min 0.1
								-max 2
								-value 0.2
								-cc "float $basesNewRad = getFloatFromSlider(\"basesRadiusSlider\"); changeBasesWidth($basesNewRad); "
								"basesRadiusSlider"
								;
						rowColumnLayout -numberOfColumns 1 -columnSpacing 1 5 -columnOffset 1 "left" 100;
							button -l ("DNA Backbone") -c ""  -w 140;
				setParent ..;	
			setParent ..;	
		}





	dockControl 
		-content $myWindow
		-l "Display"
		-area "right"
		-allowedArea "right"
		-w 400
		-s 1
		-epo 1
	;	
}


/*
5 Sept
*/
global proc drawInformationWindow(){
	global int $numberOfAtoms, $numberOfHeterogens, $numberOfAtms, $numberOfResidues, $numberOfSceneResidues, $numBonds, $numberOfChains, $numberOfSheets, $numberOfSlabs, $numberOfStrands, $numberOfHelixes;
	global string $title, $compnd, $header, $author, $source, $keywds, $expdta;

	global string $sceneElements[];
	global string $sceneResidues[];
	global string $sceneAminoAcids[];
	global string $sceneNucleotides[];
	global string $sceneStandardResidues[];
	global string $sceneNonStandardResidues[];
	global string $sceneNonStandardResiduesNiceNames[];
	global int $helixClass[];

	global int $isThereDNA;		

	string $myWindow = `window`;





	columnLayout;
	frameLayout -collapsable true -l "PDB information" -w 390 -lv 1 "pdbinfo";
			text -l ("\n"+$title) -fn "boldLabelFont";
			text -l ("Author: "+$author) -al "left";
			text -l ("Source: "+$source) -al "left";
			text -l ("Compound: "+$compnd) -al "left";
			if ($keywds != ""){
				text -l ("Keywords: "+$keywds) -al "center";
			}
			text -l ("Header: "+$header) -al "left";
	setParent..;



			

	frameLayout -collapsable true -l "Structure" -w 390 -lv 1 "pdbstructure";
			text -l ("Total atoms: "+$numberOfAtoms) -al "left";
			text -l ("Atoms: "+$numberOfAtms) -al "left";
			text -l ("Atoms in heterogen residues: "+$numberOfHeterogens) -al "left";
			text -l ("Total bonds: "+$numBonds) -al "left";
			text -l ("Chemical elements: "+size($sceneElements)) -al "left";
				string $chemEl;
				for ($i=0; $i<size($sceneElements); $i++){
					$chemEl = $chemEl + `getElementsNiceNames($sceneElements[$i])` + "\n";
				}
			text -l ($chemEl) -al "center";


			text -l ("Size (number of amino acids): "+$numberOfResidues+", of which, "+$numberOfSceneResidues+" are distinct.") -al "left";
				string $res;
				if ($numberOfResidues >= 100){
					$res = "This molecule is a PROTEIN.";
				} else if ($numberOfResidues <= 99 || $numberOfResidues >= 50){
					$res = "This molecule is a POLYPEPTIDE.";
				} else if ($numberOfResidues >= 10 || $numberOfResidues <= 49){
					$res = "This molecule is a PEPTIDE.";
				} else if ($numberOfResidues >= 2 || $numberOfResidues <= 9){
					$res = "This molecule is an OLIGOPEPTIDE.";
				}
			text -l $res -al "center" -fn "boldLabelFont";
	

			if ($numberOfHeterogens > 0){
				string $nonstandard;
				text -l ("Non-standard residues: ") -al "left";
						for ($i=0; $i<size($sceneNonStandardResidues); $i++){
							$nonstandard = $nonstandard + "\n     "+$sceneNonStandardResiduesNiceNames[$i];
						}
				text -l $nonstandard -al "center";
			}


			text -l ("Standard residues: ") -al "left";	
				string $stan;
				for ($i=0; $i<size($sceneStandardResidues); $i++){
					$stan = $stan + "\n     "+`getResiduesNiceNames($sceneStandardResidues[$i])`;
				}

			text -l $stan -al "center";

			if (size($sceneStandardResidues) == 20){
				text -l "All 20 standard amino acids are found in the molecule." -al "center" -fn "boldLabelFont";
			}



			text -l ("Number of chains: "+$numberOfChains) -al "left";
			text -l ("Number of bonds: "+$numBonds) -al "left";



			if ($numberOfHelixes > 0){
				text -l ("Number of helixes: "+$numberOfHelixes+". Types: ") -al "left";

				string $type;
				for ($i=0; $i<size($helixClass); $i++){
					$type = $type + "\n     " + `getHelixesNiceTypes($helixClass[$i])`;
				}
				text -l $type -al "left";
			}



			if ($numberOfSheets > 0) {
				text -l ("Number of sheets: "+$numberOfSheets) -al "left";
				text -l ("Total strands: "+$numberOfStrands) -al "left";
			}



			if ($isThereDNA == 1) {
				text -l ("Number of DNA bases: "+$numberOfSlabs) -al "left"
				text -l ("DA: "+`baseCount("DA")`) -al "left";
				text -l ("DC: "+`baseCount("DC")`) -al "left";
				text -l ("DT: "+`baseCount("DT")`) -al "left";
				text -l ("DG: "+`baseCount("DG")`) -al "left";
			}
	setParent..;



	dockControl 
		-content $myWindow
		-l "Info"
		-area "right"
		-allowedArea "right"
		-w 400
		-s 1
		-epo 1
	;
}









							/****** Funciones auxiliares Interfaz ******/

global proc float getFloatFromSlider(string $floatSlider){
	return `floatSliderGrp -q -value $floatSlider`;
}

global proc int getIntFromSlider(string $intSlider){
	return `intSliderGrp -q -value $intSlider`;
}

global proc float[] getColorFromSlider(string $colorSlider){
	//Tanto para el color de la luz como para el color de su sombra
	return `colorSliderButtonGrp -q -rgb $colorSlider`;
}

global proc string getSelectedFromCollection(string $collection){
	//Siempre para los buttons de la colección "hetatmCameras"
	return `radioCollection -q -sl $collection`;
}

global proc string getLabelFromSelected(string $selected){
	return `radioButton -q -ann $selected`;
}

global proc string getCameraNiceName(string $cameraName){
	//Le quitamos los guiones y los sustituimos por espacios, para que se lea mejor como label
	string $result;

	string $arr[] = `stringToCharArray($cameraName) `;
	for ($i=0; $i<size($arr); $i++){
		if ($arr[$i] == "_"){
			$arr[$i] = " ";
		}
	}

	$result = stringArrayToString($arr, "");


	//Camera_Residue_A_154_SO4 -> Camera Residue A 154 SO4 -> Residue SO4, Chain A, #154  
	string $better = `substring $result 16 (size($result))`;	//A 154 SO4
	$chain = `substring $better 1 1`;	// A
	$better = `substring $better 3 (size($better))`;
	$num = `substring $better 1 3`;	// 154
	$better = `substring $better 5 (size($better))`;	//SO4
	$res = $better;
	//$res = `substring $better 1 (size($better))`;

	$better = "Residue "+$res+", Chain "+$chain+", #"+$num;
	return $better;
}


global proc callToBackbone(string $backboneType){
	//backboneType : "full", "minimal", "sidechains"
	global string $moleculeMode;

	if ($moleculeMode == "secondary"){
		//Cuadro de diálogo

			string $userResponse = `confirmDialog 
				-title "Feature only for Ball & Stick mode"
				-message "Do you want to change the current display mode?"
				-button "Yes"
				-button "No"
				-cancelButton "No"
			`;


			if ($userResponse == "Yes"){

				drawCPK("ballandstick");

				if ($backboneType == "full"){
					showFullBackbone();
				} else if ($backboneType == "minimal"){
					showMinimalBackbone();
				} else if ($backboneType == "sidechains"){
					showSideChains();
				}
			}

	} else {

		//Visualizar directamente
		if ($backboneType == "full"){
			showFullBackbone();
		} else if ($backboneType == "minimal"){
			showMinimalBackbone();
		} else if ($backboneType == "sidechains"){
			showSideChains();
		}
	}
}





















/********** showWaters() **********/
/*
Description: Hace que vuelvan a aparecer en la escena las moléculas de agua
Date: Creation: May 5 2015.  
*/
global proc showWaters(int $onOff){
	string $group[] = `ls "Residue*HOH"`;	//para que esto no de un error y pare la ejecución en el caso de que no haya aguas

	if (size($group) > 0){
		if ($onOff == 0){
			hide "Residue*HOH";
		} else {
			showHidden "Residue*HOH";
		}	
	}
}




/********** showBonds() **********/
/*
Description: Hace desaparecer los enlaces de la escena
Date: Creation: 3 August
*/
global proc showBonds(int $onOff){
	global int $numBonds;

	if ($numBonds > 0){
		if ($onOff == 0){		
			hide "*_bond_*";
			// hide "conects_backbone_*_bond_*";
			// hide "conects_hetatm_backbone_*_bond_*";	//these should be shown at showMinimalBackbone y showFullBackbone
			// hide "hetatm_backbone_*_bond_*";
			// hide "hetatm_*_bond_*";
		} else {
			showHidden "*_bond_*";
			showSlabs(0);
		}
	} 
}






/********** showAllAtoms() **********/
/*
Description: Hace desaparecer los átomos de la escena
Date: Creation: 3 August
*/
global proc showAllAtoms(int $onOff){
	global int $numberOfHeterogens;
	global int $isThereCarcass;

	//Depende del modo de visualización actual
	global string $moleculeMode;


	if ($moleculeMode == "secondary"){
		if ($onOff == 1){
			showHetatms(1);
		} else {
			showHetatms(0);
		}



	} else {
		if ($isThereCarcass == 0){
			if ($onOff == 1){
				if ($numberOfHeterogens > 0){
					showHidden "atom*" "*Element*|hetatm*";
				} else {
					showHidden "atom*";
				} 
			} else {
				if ($numberOfHeterogens > 0){
					hide "atom*" "*Element*|hetatm*";
				} else {
					hide "atom*";
				} 
			}


		} else {
			if ($onOff == 1){
				showHidden -below "Molecule";
			} else {
				hide "Molecule"	;		
			}
		}
	}
}

global proc showAtoms(int $onOff){
	global int $isThereCarcass;

	if ($isThereCarcass == 0){
		if ($onOff == 1){
			select -cl;

			showHidden "atom*";

			select "atom*";
		} else {
			hide "atom*";
		}



	} else {
		if ($onOff == 1){
			select -cl;

			showHidden "Molecule|Chain*|Residue*|*Element*|atom*";
			showHidden "Carcass|Chain*|Residue*|*Element*|atom*";

			select "Molecule|Chain*|Residue*|*Element*|atom*" "Carcass|Chain*|Residue*|*Element*|atom*";
		} else {
			hide "Molecule|Chain*|Residue*|*Element*|atom*";
			hide "Carcass|Chain*|Residue*|*Element*|atom*";
		}
	}
}


//Descripción: enseña los átomos de modo hetatm, no sus enlaces.
global proc showHetatms(int $onOff){
	//No confundir con `ls "hetatm_*_bond*"`;

	global int $isThereCarcass;
	global int $numberOfHeterogens;


	if ($isThereCarcass == 0){
		if ($onOff == 1 && $numberOfHeterogens > 0){
			select -cl;

			showHidden "*Element*|hetatm*";
			select "*Element*|hetatm*";

		} else if ($onOff == 0 && $numberOfHeterogens > 0){
			hide "*Element*|hetatm*";
		}
	} else {
		if ($onOff == 1 && ($numberOfHeterogens > 0)){
			select -cl;

			hide "Molecule|Chain*|Residue*|*Element*|hetatm*";
			hide "Carcass|Chain*|Residue*|*Element*|hetatm*";

			select "*Element*|hetatm*" "*Element*|hetatm*";
		} else if ($onOff == 0 && ($numberOfHeterogens > 0)){
			hide "Molecule|Chain*|Residue*|*Element*|hetatm*";
			hide "Carcass|Chain*|Residue*|*Element*|hetatm*";
		}
	}
}







/********** showHelixes() **********/
/*
Description: Hace desaparecer las hélices de la escena
Date: Creation: 4 August
También hace desaparecer la backbone de esa hélice, ya que se pinta con ella.
*/
global proc showHelixes(int $onOff){
	global int $numberOfHelixes;

	if ($onOff == 0 && $numberOfHelixes > 0){
		hide ("*Helix*");
	} else if ($onOff == 1 && $numberOfHelixes > 0){
		select -clear;

		showHidden ("*Helix*");
		select ("*Helix*");
	}	
}

global proc showHelix(int $h, int $onOff){
	//"roundedHelix"+($h+1)+"_"+$chain
	//MODE
	if ($onOff == 1){
		select -clear;

		showHidden ("*Helix_" + $h + "*");
		select ("*Helix_" + $h + "*");
	} else {
		hide ("*Helix_" + $h +"*");
	}
}







/********** showSheets() **********/
/*
Description: Hace que vuelvan a aparecer en la escena las moléculas de agua
Date: Creation: 4 August
*/
global proc showSheets(int $onOff){
	global int $numberOfSheets;

	if ($onOff == 0 && $numberOfSheets > 0){
		select -clear;

		hide ("*_Strand_*");
		hide ("sense*");
	} else if ($onOff == 1 && $numberOfSheets > 0){
		select -clear;

		showHidden ("*_Strand_*");
		showHidden ("sense*");

		select ("*_Strand_*");
	}	
}

global proc showSheet(string $sheet, int $onOff){
	//"edgedSheet_"+($s+1)+"_from_Strand_"+$strandIds[$s]+"_"+$chain
	//$strandIds[]
	if ($onOff == 1){
		select -clear;

		showHidden ("*_Strand_"+$sheet+"*");
		//showHidden ("sense*");

		select ("*_Strand_"+$sheet+"*");
	} else {
		select -clear;

		hide ("*_Strand_"+$sheet+"*");
		//hide ("sense*");
	}
}












/********** showFullBackbone() **********/
/*
Esconder todos los que no sean C, CA, O o N
			*** Para modos distintos a Secondary Structure ***
31 july-2 august
*/
global proc showFullBackbone(){
	global string $sceneElements[];
	global int $isThereDNA;


		//Se esconde todo
		showAllAtoms(0);
		showBonds(0);
		showWaters(0);


		//Aminoácidos
		showHidden `ls "atom_C_*"`;
		showHidden `ls "atom_CA_*"`;
		showHidden `ls "atom_O_*"`;
		showHidden `ls "atom_N_*"`;

		showHidden `ls "*Element*|hetatm_C_*"`;
		showHidden `ls "*Element*|hetatm_CA_*"`;
		showHidden `ls "*Element*|hetatm_O_*"`;
		showHidden `ls "*Element*|hetatm_N_*"`;
		
		showHidden `ls "backbone_*"`;
		showHidden `ls "backboneO_*"`;
		showHidden `ls "*conects_*_backbone"`;





		//Esconder los átomos de otros elementos HETATM que puede haber en la escena
		for ($e=0; $e<size($sceneElements); $e++){
			if ($sceneElements[$e] != "C" && $sceneElements[$e] != "N" && $sceneElements[$e] != "O"){
				string $nameBond = $sceneElements[$e]+"_bond*";
				string $atomBond = "*Element*|hetatm_"+$sceneElements[$e]+"*";

				hide `ls $nameBond`;
				hide `ls $atomBond`;
			}
		}	


		//ADN: {P, O3', O4', O5', C1', C2', C3', C4', C5'}
		if ($isThereDNA == 1){
			showHidden `ls "atom_P_*"`; 		
			showHidden `ls "atom_*__*"`; 
			showHidden `ls "backboneSC_*"`;
			showHidden `ls "atom_*__*"`; 		
		}
}






/********** showMinimalBackbone() **********/
/*
Esconder todos los que no sean C, CA o N en caso de aminoácidos, y C4' en caso de ADN
31 july
*/
global proc showMinimalBackbone(){
	global string $sceneElements[];
	global int $isThereDNA;


		showAllAtoms(0);
		showBonds(0);
		showWaters(0);


		//Aminoácidos
		showHidden `ls "atom_C_*"`;
		showHidden `ls "atom_CA_*"`;
		showHidden `ls "atom_N_*"`;
		showHidden `ls "*Element*|hetatm_C_*"`;
		showHidden `ls "*Element*|hetatm_CA_*"`;	
		showHidden `ls "*Element*|hetatm_N_*"`;
		showHidden `ls "*conects_*_backbone"`;
		showHidden `ls "*backbone_"`;


		//Esconder los átomos de otros elementos HETATM que puede haber en la escena
		for ($e=0; $e<size($sceneElements); $e++){
			if ($sceneElements[$e] != "C" && $sceneElements[$e] != "N" && $sceneElements[$e] != "O"){
				string $nameBond = $sceneElements[$e]+"_bond*";
				string $atomBond = "*Element*|hetatm_"+$sceneElements[$e]+"*";

				hide `ls $nameBond`;
				hide `ls $atomBond`;
			}
		}


		//ADN: {P, O3', O5', C3', C4', C5'}
		if ($isThereDNA == 1){
			showHidden `ls "atom_P*"`; 
			showHidden `ls "atom_O3__*"`; 
			showHidden `ls "atom_O5__*"`; 
			showHidden `ls "atom_C3__*"`; 
			showHidden `ls "atom_C4__*"`; 
			showHidden `ls "atom_C5__*"`; 
		}

		showHidden `ls "backbone_*"`;	
}



/********** showSideChains() **********/
/*
*/
global proc showSideChains(){
	global string $sceneElements[];
	global int $isThereDNA;

		showAtoms(1);
		showBonds(1);
		showWaters(0);

		//Escondemos todo lo que se mostraba en FullBackbone

		//Aminoácidos
		hide `ls "atom_C_*"`;
		hide `ls "atom_CA_*"`;
		hide `ls "atom_O_*"`;
		hide `ls "atom_N_*"`;

		hide `ls "*Element*|hetatm_C_*"`;
		hide `ls "*Element*|hetatm_CA_*"`;
		hide `ls "*Element*|hetatm_O_*"`;
		hide `ls "*Element*|hetatm_N_*"`;
		
		hide `ls "backbone_*"`;
		hide `ls "backboneO_*"`;
		hide `ls "*conects_*_backbone"`;



		// //Esconder los átomos de otros elementos HETATM que puede haber en la escena
		// for ($e=0; $e<size($sceneElements); $e++){
		// 	if ($sceneElements[$e] != "C" && $sceneElements[$e] != "N" && $sceneElements[$e] != "O"){
		// 		string $nameBond = $sceneElements[$e]+"_bond*";
		// 		string $atomBond = "*Element*|hetatm_"+$sceneElements[$e]+"*";

		// 		hide `ls $nameBond`;
		// 		hide `ls $atomBond`;
		// 	}
		// }



		if ($isThereDNA == 1){
			hide `ls "atom_P_*"`; 		
			hide `ls "atom_*__*"`; 
			hide `ls "backboneSC_*"`;
			hide `ls "atom_*__*"`; 		
		}

		select -clear;
}







/********** showWholeMolecule() **********/
/*
*/
global proc showWholeMolecule(){
	global string $moleculeMode;

	showAllAtoms(1);
	showBonds(1);
	if ($moleculeMode == "cpk"){
		showWaters(1);
	} else {
		showWaters(0);
	}
}





/********** showChain(string $letter) **********/
/*
Esconde todas las cadenas excepto esa. 
3 aug
*/
global proc showChain(string $letter, int $onOff){
	global int $numberOfSheets, $numberOfHelixes, $numberOfHeterogens, $isThereDNA;
	global int $keepChainTraces, $keepHelixes, $keepSheets, $keepSlabs;

	global string $moleculeMode;


	if ($onOff == 0){
		select -cl;

		hide ("Molecule|Chain_"+$letter);				//Molecule|Chain*|Residue*|*Element*|
		string $bonds[] = `ls ("*bond*"+"_"+$letter)`;	if (size($bonds) > 0) hide ("*bond*"+"_"+$letter);		
		if ($keepChainTraces == 0) hide ("*ChainTrace_"+$letter);


		//Busco si hay hélices en esa cadena
		if ($numberOfHelixes > 0 && $keepHelixes == 0){
			string $h[] = `ls ("*Helix*_"+$letter)`;
			if (size($h) > 0){
				hide ("*Helix*_"+$letter);
			}		
		}


		//Busco si hay sheets en esa cadena
		if ($numberOfSheets > 0 && $keepSheets == 0){
			string $s[] = `ls ("*Sheet*_"+$letter)`;
			if (size($s) > 0){
				hide ("*Sheet*_"+$letter);
			}		
		}


		//Compruebo si esa cadena es de ADN
		//if ($moleculeMode == "secondary") showConects($letter, 0);
		string $temp[] = `ls ("*DNAChainTrace_"+$letter)`;
		if (size($temp) > 0){
			//Es una cadena de adn
			if ($keepSlabs == 0) hide ("*_slab_*" + $letter);	
		}








	} else if ($onOff == 1){
		select -cl;

		showHidden ("Molecule|Chain_"+$letter);
		if ($moleculeMode == "secondary" || $keepChainTraces == 1) showHidden ("*ChainTrace_"+$letter);
		string $bonds[] = `ls ("*bond*"+"_"+$letter)`;	if (size($bonds) > 0) showHidden ("*bond*"+"_"+$letter);

		//Busco si hay hélices en esa cadena
		if ($numberOfHelixes > 0 && ($keepHelixes == 1 || $moleculeMode == "secondary" )){
			string $h[] = `ls ("*Helix*_"+$letter)`;
			if (size($h) > 0){
				showHidden ("*Helix*_"+$letter);
				select -add ("*Helix*_"+$letter);
			}		
		}


		//Busco si hay sheets en esa cadena
		if ($numberOfSheets > 0 && ($keepSheets == 1 || $moleculeMode == "secondary" )){
			string $s[] = `ls ("*Sheet*_"+$letter)`;
			if (size($s) > 0){
				showHidden ("*Sheet*_"+$letter);
				select -add ("*Sheet*_"+$letter);
			}		
		}


		//Compruebo si esa cadena es de ADN
		//if ($moleculeMode == "secondary") showConects($letter, 0);
		string $temp[] = `ls ("*DNAChainTrace_"+$letter)`;
		if (size($temp) > 0){
			//Es una cadena de adn
			if ($keepSlabs == 1) showHidden ("*_slab_*" + $letter);	
		}



		select ("Molecule|Chain_"+$letter);
		if ($moleculeMode == "secondary" || $keepChainTraces == 1)  select -add ("*ChainTrace_"+$letter) ;
		if (size($bonds) > 0) select -add ("*bond*"+"_"+$letter);
		//if ($numberOfHelixes > 0 && ($moleculeMode == "secondary" || $keepHelixes == 1)) select -add ("*Helix*_"+$letter);
		//if ($numberOfSheets > 0 && ($moleculeMode == "secondary" || $keepSheets == 1)) select -add ("*Sheet*_"+$letter);
		if (size($temp) > 0 && $keepSlabs == 1) select -add ("*_slab_*" + $letter);	
 	}


	if ($moleculeMode == "secondary") showConects($letter, 0);
}


global proc showAllChains(int $onOff){
	global int $numberOfChains;
	global string $alphabet[];

	for ($i=0; $i<$numberOfChains; $i++){
		if ($onOff == 1){
			showChain($alphabet[$i], 1);
		} else {
			showChain($alphabet[$i], 0);
		}
	}
}


//1 Sept
global proc showResidue(string $resName, int $onOff){
	global string $moleculeMode;
	global string $sceneResidues[];
	global int $isThereDNA;
	string $bonds[] = `ls ("*_bond_*_"+$resName+"_*")`;


	


	if ($onOff == 1){
		showHidden 	("Residue_*_" + $resName);		//ALL ATOMS
		if (size($bonds) > 0) showHidden $bonds; 	//BONDS
		if ($isThereDNA == 1) showHidden ($resName+"_slab_*");

		//Select
		select ("Residue_*_" + $resName);
		if (size($bonds) > 0) select -add $bonds; 	
		if ($isThereDNA == 1) select -add ($resName+"_slab_*");		

	} else {
		select -clear;

		hide ("Residue_*_" + $resName);		//ATOMS, HETATMS
		if (size($bonds) > 0) hide $bonds; 	//BONDS
		if ($isThereDNA == 1) hide ($resName+"_slab_*");
	}
}


global proc showElement(string $element, int $onOff){
	if ($onOff == 1){
		select -clear;

		showHidden ($element+"_Element_*");		//C_Element_A_002_HYP
		select ($element+"_Element_*");
	} else {
		select -clear;

		hide ($element+"_Element_*");
	}

}


global proc showSlabs(int $onOff){
	global int $isThereDNA;
	global int $keepSlabs;
	// global int $numberOfSlabs;	//Número de bases

	// string $slabs[] = `ls "*slab*"`;
	// $numberOfSlabs = size($slabs);

	if ($isThereDNA == 1){
		if ($onOff == 1){
			showHidden "*slab*";
		} else {
			if ($keepSlabs == 0) hide "*slab*";
			else if ($keepSlabs == 1) showHidden "*slab*";
		}
	} 
}


global proc showSlab(string $base, int $onOff){
	global int $isThereDNA;
	global int $keepSlabs;

	if ($isThereDNA == 1){
		if ($onOff == 1){
			select -clear;

			showHidden ($base+"*slab*");
			select ($base+"*slab*");
		} else {
			if ($keepSlabs == 0) hide ($base+"*slab*");
			else if ($keepSlabs == 1) {
				showHidden ($base+"*slab*");
				select ($base+"*slab*");
			}
		}
	} 
}


global proc showConects(string $letter, int $onOff){
	//Enlaces con la palabra "conects", enlazan un átomo con un hetatm
	string $conects[] = `ls ("*conects*"+"_"+$letter)`;

	if ($onOff == 1){
		if (size($conects) > 0) showHidden ("*conects*"+"_"+$letter) ;
	} else {
		if (size($conects) > 0) hide ("*conects*"+"_"+$letter) ;
	}
}

/********** showAll(int $onOff) **********/
proc showAll(int $onOff){
	if ($onOff == 1){
		showHidden "Scene";
	} else {
		hide "Scene";
	}
}




/********** showCarcass(int $yn) **********/
/*
20 aug
*/
global proc showCarcass(int $yn){
	global int $isThereCarcass;

	if ($yn == 1){
		if ($isThereCarcass == 1){
			showHidden "Carcass|*|*|*";
		}
	} else if ($yn == 0){
		if ($isThereCarcass == 1){
			hide  "Carcass|*|*|*";
		} 
	}
}


/********** showAllChainTraces(int $yn) **********/
/*
21 aug
Dos tipos: smoothAminoacidChainTrace, regularAminoacidChainTrace
*/
global proc showAllChainTraces(int $yn){
	global string $modeAminoacids;


	if ($yn == 1){
		select -clear;

		showHidden ($modeAminoacids+"ChainTrace*");
		select ($modeAminoacids+"ChainTrace*");
	} else {
		hide ($modeAminoacids+"ChainTrace*");
	}
}


/********** showChainTrace(string $letter, int $yn) **********/
/*
21 aug
*/
global proc showChainTrace(string $letter, int $yn){	//Habrá que cambiarlo para que si se han calculado otras ChainTraces, mostrar la última
	global string $modeAminoacids;
	if ($yn == 1){
		select -clear;

		showHidden ($modeAminoacids+"*ChainTrace_"+$letter);
	} else {
		hide ($modeAminoacids+"*ChainTrace_"+$letter);
	}
}





/*
Descripción: Como hay tres tipos de dibujado de hélices, para hacer operaciones con ellas hay que seleccionar la última que esté dibujada.
*/
global proc string[] selectCurrentHelixes(){
	global string $helixCurrentShape;
	string $beginning;

		// edgedHelix
		// roundedHelix
		// flatHelix

	if ($helixCurrentShape == "rounded"){
		$beginning = "roundedHelix";
	} else if ($helixCurrentShape == "edged"){
		$beginning = "edgedHelix";
	} else if ($helixCurrentShape == "flat"){
		$beginning = "flatHelix";
	}


	string $group[] = `ls ($beginning+"*") `;	//Después, con un select, están todas seleccionadas
	return $group;
}






/*
Descripción: Como hay tres tipos de dibujado de sheets, para hacer operaciones con ellas hay que seleccionar la última que esté dibujada.
*/
global proc string[] selectCurrentSheets(){
	global string $sheetCurrentShape;
	string $beginning;
		// edgedSheet
		// roundedSheet
		// flatSheet

	if ($sheetCurrentShape == "rounded"){
		$beginning = "roundedSheet";
	} else if ($sheetCurrentShape == "edged"){
		$beginning = "edgedSheet";
	} else if ($sheetCurrentShape == "flat"){
		$beginning = "flatSheet";
	}

	string $group[] = `ls -transforms ($beginning+"_*") `;	//Después, con un select, están todas seleccionadas
	return $group;
}







/*
Descripción: Como hay dos tipos de dibujado de chain trace, para hacer operaciones con ellas hay que seleccionar la última que esté dibujada.
		Type: amino, dna

			// Mode Aminoacid: 	"smoothAminoacid", "regularAminoacid"
			// Mode DNA: 		"roundedDNA", "edgedDNA", "flatDNA"
*/
global proc string[] selectCurrentChainTrace(string $type){
	global string $aminoChainTraceCurrentShape;
	global string $dnaChainTraceCurrentShape;
	string $beginning;

	//smoothAminoacidChainTrace_
	//roundedDNAChainTrace_


	if ($type == "amino"){
		if ($aminoChainTraceCurrentShape == "smooth"){
			$beginning = "smoothAminoacid";
		} else if ($aminoChainTraceCurrentShape == "regular"){
			$beginning = "regularAminoacid";
		}
	} else if ($type == "dna"){
		if ($dnaChainTraceCurrentShape == "rounded"){
			$beginning = "roundedDNA";
		} else if ($dnaChainTraceCurrentShape == "edged"){
			$beginning = "edgedDNA";
		} else if ($dnaChainTraceCurrentShape == "flat"){
			$beginning = "flatDNA";
		}
	}





	string $group[] = `ls -transforms ($beginning+"ChainTrace_*") `;	//Después, con un select, están todas seleccionadas
	return $group;
}






global proc keepHelixes(int $yn){
	global int $keepHelixes;

	if ($yn == 1){
		$keepHelixes = 1;
	} else {
		$keepHelixes = 0;
	}
}




global proc keepSheets(int $yn){
	global int $keepSheets;

	if ($yn == 1){
		$keepSheets = 1;
	} else {
		$keepSheets = 0;
	}
}




global proc keepChainTraces(int $yn){
	global int $keepChainTraces;

	if ($yn == 1){
		$keepChainTraces = 1;
	} else {
		$keepSheets = 0;
	}
}




//Date of start and finish: July 18
global proc changeBasesWidth(float $rad){
	string $bases[] = `ls "polyCylinder_*slab*" `;

	for ($j=0; $j<size($bases); $j++){
	    setAttr ($bases[$j]+".radius") $rad;
	}
}






//Mode: dna para enlaces de adn, slabs para enlaces entre bases
//Date of start and finish: July 18
global proc drawConnectedBases(int $nA, int $nB, int $p, string $mode){
	//nA y nB son puntos
	global string $atomNames[];
	global vector $coordinates[];
	global string $residueNames[];
	global int $dnaStrand1[], $dnaStrand2[];
	global int $numberOfSlabs;




	vector $coordA, $coordB;
	string $nucleicA, $nucleicB;	//A, C, T, G
	string $curve1, $curve2;



	$coordA = $coordinates[$nA];
	$coordB = $coordinates[$nB];

	$nucleicA = $residueNames[$nA];
	$nucleicB = $residueNames[$nB];

	string $idA = $atomNames[$nA];	//nombres de los átomos
	string $idB = $atomNames[$nB];


	$numberOfSlabs++;


	if ($nucleicA == $nucleicB){
		//Puede que ser refiera al dibujado de un enlace entre dos átomos, o al DIBUJADO DE UN SLAB entre el principio y el final del residuo
		//Se dibuja un sólo cilindro y las coordenadas de cada punto son las mismas
		string $mode;


		if ($idA == "C4'" && ($idB == "N6" || $idB == "N2" || $idB == "O4" || $idB == "N4" )) {
			$mode = "slabs";
		} else if ($idB == "C4'" && ($idA == "N6" || $idA == "N2" || $idA == "O4" || $idA == "N4" )){ 
			$mode = "slabs";
		} else {
			$mode = "dna";
		}


		drawCylinder($coordA, $coordB, $nucleicA, $nA, $nB, $mode, $p);
	} else {
		//Dibujar dos cilindros y cambiar los dos puntos 		
		//vector $midPoint = << ($coordA.x+$coordB.x)/2, ($coordA.y+$coordB.y)/2, ($coordA.z+$coordB.z)/2 >>;


							/* SON SLABS */
		vector $midPoint = calculateMidPoint($coordA, $coordB);
		drawCylinder($midPoint, $coordA, $nucleicA, $nA, $nB, "slabs", $p);
		drawCylinder($midPoint, $coordB, $nucleicB, $nB, $nA, "slabs", $p);
	}
}







/********** assignColorToHelixByType(int $helixType, string $helixName) **********/
/*Date of start and finish: 14 July*/
global proc assignColorToHelixByType(int $helixType, string $helixName){
	float $color[];


	if ($helixType == 1){							// Right-handed alpha (default)                1
		$color = {225,0,125};		//Fucsia
	} else if ($helixType == 2){					// Right-handed omega                          2
		$color = {194,255,0};		//Lima
	} else if ($helixType == 3){					// Right-handed pi                             3
		$color = {255,209,35};		//Amarillo
	} else if ($helixType == 4){					// Right-handed gamma                          4
		$color = {235,0,38};		//Rojo
	} else if ($helixType == 5){					// Right-handed 3 - 10                         5
		$color = {229,83,0}; 		//Naranja  
	} else if ($helixType == 6){					// Left-handed alpha                           6
		$color = {112,46,176};		//Violeta
	} else if ($helixType == 7){					// Left-handed omega                           7
		$color = {0,125,0};			//Verde
	} else if ($helixType == 8){					// Left-handed gamma                           8
		$color = {239,153,118};		//Naranja
	} else if ($helixType == 9){					// 2 - 7 ribbon/helix                          9
		$color = {161,54,212};		//Morado II
	} else if ($helixType == 10){					// Polyproline                                10
		$color = {255,105,180};		//Rosa
	}

								

	string $shaderName = "helixType_"+$helixType+"_Shader";			//Shader: "helixType1_Shader"

	assignShader($shaderName, $color, $helixName);

}


global proc assignColorToAllHelixesByType(){
	//Teniendo en cuenta que los shaders ya se habían creado
	global int $helixClass[];
	string $helixes[] = `ls -shapes ("*Helix_*")` ;

	for ($i=0; $i<size($helixes); $i++){
		int $number = `match "[0-9]+" $helixes[$i] `;
		$number = $number - 1;


		//Buscar en el vector de tipos de las hélices
		string $shaderName = ("helixType_"+$helixClass[$number]+"_Shader");

		assignExistingShader($shaderName, $helixes[$i]);
	}
}






/********** assignColorToAllHelixesByNumber() **********/
//Description: Le asigna un color distinto a cada hélice, independientemente de su tipo
//Date of start and finish: 14 July

global proc assignColorToAllHelixesByNumber(){
	string $helixes[] = `ls -shapes ("*Helix_*")` ;

	for ($i=0; $i<size($helixes); $i++){
		int $h = $i+1;
		int $red = ($h*40)%255;
		int $green = ($h*45)%255;
		int $blue = ($h*100)%255;

		float $red2 = $red;
		float $green2 = $green;
		float $blue2 = $blue;

		float $color[] = { $red2, $green2, $blue2 };
		string $shaderName = ("helixNumber_"+$h+"_Shader");			//Shader: "helixNumber_1_Shader"

		assignShader($shaderName, $color, $helixes[$i]);
	}
}







/********** assignColorToStrandByNumber(int $s, string $strandName) **********/
//Description: Le asigna un color distinto a cada strand
//Date of start and finish: 22 July

global proc assignColorToStrandByNumber(int $s, int $sheet, string $strandName){
	//s = strand
	int $red, $green, $blue;
	float $red2, $green2, $blue2;
	float $color[];

	$s++;



	if ($sheet%3 == 0){
		//Azul
		$red = ($sheet+20+$s*5)%255;
		$green = ($sheet+20+$s*20)%255;
		$blue = ($sheet+100+$s*5)%255;

		if ($blue < 100){
			$blue = ($sheet+100+$s*5)%255; 
		}
	} else if ($sheet%2 == 0){
		//Verde
		$red = ($sheet+20+$s*20)%255;
		$green = ($sheet+100+$s*5)%255;
		$blue = ($sheet+20+$s*5)%255;

		if ($green < 100){
			$green = ($sheet+100+$s*5)%255; 
		}
	} else {
		//Roja
		$red = ($sheet+100+$s*5)%255;
		$green = ($sheet+20+$s*20)%255;
		$blue = ($sheet+20+$s*5)%255;

		if ($red < 100){
			$red = ($sheet+100+$s*5)%255; 
		}
	}




	$red2 = $red;
	$green2 = $green;
	$blue2 = $blue;
	$color = { $red2, $green2, $blue2 };

	string $shaderName = "strandNumber_"+($s+1)+"_Shader";			//Shader: "strandNumber1_Shader"

	assignShader($shaderName, $color, $strandName);
}





global proc assignMonochromeToAllSheets(float $color[]){
	string $sheets[] = `ls "*Sheet*" "sense*"`;	//Color para sheets y senses

	string $search[] = `ls -mat "sheetsMonochrome_Shader"`;
	string $shaderName = "sheetsMonochrome_Shader";


	if (size($search) == 1){
		//Ya existía y sólo hay que cambiarle el color
		setAttr($shaderName + ".color") $color[0] $color[1] $color[2]; 
	} else {
		for ($i=0; $i<size($sheets); $i++){
			if ($i == 0){
				//Crear el shader
				assignShaderHSV($shaderName, $color, $sheets[$i]);
			} else {
				assignExistingShader($shaderName, $sheets[$i]);
			}
		}
	}
}






/********** assignColorToHelixByChain(string $chain, string $helixName) **********/
//Description: Le asigna un color a cada hélice, que depende de la cadena a la que pertenece
//Date of start and finish: 20 July

global proc assignColorToHelixByChain(){
	global string $alphabet[];

	string $heli[] = `ls -dag -leaf "*Helix_*"`;


	for ($i=0; $i<size($heli); $i++){
		$chain = `match "_[A-Z]_" $heli[$i]`;
		$chain = `substring $chain 2 (size($chain))`;
		$chain = `substring $chain 1 1`;

		string $shaderName = ("helixChain_"+$chain+"_Shader");	//Shader: "helixChain_A_Shader"
		//print $shaderName;


		float $color[];

		int $n = 0;
		while($chain != $alphabet[$n]){
			$n++;
		}


		int $red = ($n*45)%255;
		int $green = ($n*210)%255;
		int $blue = ($n*20)%255;

		float $red2 = $red;
		float $green2 = $green;
		float $blue2 = $blue;

		$color = { $red2, $green2, $blue2 };


		assignShader($shaderName, $color, $heli[$i]);
	}

	print(`ls -mat "*_Shader"`);

}








// /********** assignRainbowToCPK(string $chain, string $helixName) **********/
// global proc assignRainbowToCPK(){
// 	string $group[] = `ls -transforms "atom*"`;
// 	//print $group;
// 	int $numAtoms = size($group);
// 	//float $factor = 255/$numAtoms;
// 	//print("num atoms: "+$numAtoms+"\n");
// 	//float $red, $green, $blue;
// //	float $red2, $green2, $blue2;




// 	for ($a=1; $a<$numAtoms; $a++){
// 		// $red = (255-$a*$factor)%255;
// 		// $green = ($a*$factor)%255;
// 		// $blue = (255+$a*$factor)%255;


// 		string $b[] = `ls -transforms ("atom*"+$a)`;
// 		int $id = `match "[0-9]+$" $b[0]`;

// 		if ($id != 0){
// 			//print("ID: "+$id+" "+$b[0]+"\n");

// 			//$red = (float) (255/$numAtoms)*$id;
// 			//$red = (float) (255/$id);
// 			//print($red);
// 			//print("\n");			
// 			//float $red = (255/(float)$numAtoms*(float)$a);
// 			// float $red = (255/(float)$numAtoms*(float)$a);
// 			// float $blue = 255/(float)$numAtoms*(float)$a;
// 			// float $green = 0;
// 			// print($red);
// 			// print("\n");


// 			$ratio = $numAtoms/$a;

// 			$red = float(getRatio($id));
// 			$green = float(getRatio($id + 2/3));
// 			$blue = float(getRatio($id + 1/3));

// 						//print("get ratio id: "+$green+"\n");

// 			//Fn(Ratio), Fn(Ratio + 2 / 3), Fn(Ratio + 1 / 3)


// 			float $color[] = { $red, $green, $blue };
// 			string $shaderName = "rainbow"+$a+"_Shader";			
// 			assignShader($shaderName, $color, $group[$a]);	
// 		}


// 	}

// 	//print($group);

// }




global proc openPDB(){
	global int $fileID;
	int $ahora = openFile();

	if ($ahora != 0){
		file -f -new;

		if (`grid -q -toggle` == 1){
			grid -toggle 0;
		}

		readPDB($fileID);
		drawScene();

		DisplayLight;	//Turn on all lights

	} else {
		string $userResponse = `confirmDialog 
			-title "Error"
			-message "PDB file couldn't be opened"
			-button "Open another file"
			-button "Cancel"
			-cancelButton "Cancel"
		`;
	}

}








/************************************************************ main() ************************************************************/
/*
Description: 
Date: Creation: March 16 2015.  
*/
global proc main(){
	/*********************************************************/

							setInterface();

	/*********************************************************/

	//drawChainTrace("regularAminoacid", "roundedDNA");
	//drawChainTrace("smoothAminoacid", "roundedDNA");
	//drawChainTrace("smoothAminoacid","flatDNA"); 
	//drawChainTrace("smoothAminoacid", "edgedDNA"); 


	//drawHelixes("flat");
	//drawHelixes("rounded");
	//drawHelixes("edged");

	//drawSheets("flat");
	//drawSheets("rounded");
	//drawSheets("edged");
}

main();
